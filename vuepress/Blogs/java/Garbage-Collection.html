<!DOCTYPE html><html lang="en-US"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java垃圾回收机制 | YATING</title><meta name="description" content="分代垃圾回收机制，是基于这样一个事实：不同的对象的生命周期是不一样的"><meta name="generator" content="VuePress 1.3.0"><link rel="icon" type="image/x-icon" href="/vuepress/img/logo.ico"><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.js"></script><link rel="preload" href="/vuepress/assets/css/0.styles.7d2aa382.css" as="style"><link rel="preload" href="/vuepress/assets/js/app.6bd1f1a1.js" as="script"><link rel="preload" href="/vuepress/assets/js/7.d0d4b681.js" as="script"><link rel="preload" href="/vuepress/assets/js/12.dfb2ae5e.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/1.24456b9b.js"><link rel="prefetch" href="/vuepress/assets/js/10.75c37bf8.js"><link rel="prefetch" href="/vuepress/assets/js/11.b4e65db8.js"><link rel="prefetch" href="/vuepress/assets/js/13.5a9575b7.js"><link rel="prefetch" href="/vuepress/assets/js/14.4d7afe3c.js"><link rel="prefetch" href="/vuepress/assets/js/15.b77286f7.js"><link rel="prefetch" href="/vuepress/assets/js/16.237354e5.js"><link rel="prefetch" href="/vuepress/assets/js/17.9d42656e.js"><link rel="prefetch" href="/vuepress/assets/js/18.a4bd94c4.js"><link rel="prefetch" href="/vuepress/assets/js/19.e6c1e8d7.js"><link rel="prefetch" href="/vuepress/assets/js/20.c5e87971.js"><link rel="prefetch" href="/vuepress/assets/js/21.70092729.js"><link rel="prefetch" href="/vuepress/assets/js/22.5cae9f5c.js"><link rel="prefetch" href="/vuepress/assets/js/3.fc4541d3.js"><link rel="prefetch" href="/vuepress/assets/js/4.4baed515.js"><link rel="prefetch" href="/vuepress/assets/js/5.76a85d6e.js"><link rel="prefetch" href="/vuepress/assets/js/6.ef0f1d0a.js"><link rel="prefetch" href="/vuepress/assets/js/8.04df4219.js"><link rel="prefetch" href="/vuepress/assets/js/9.88895185.js"><link rel="stylesheet" href="/vuepress/assets/css/0.styles.7d2aa382.css"><link rel="alternate" href="/atom.xml" title="木木" type="application/atom+xml"></head><body><div id="app" data-server-rendered="true"><div id="global-layout"><div class="loading"><div><div class="loader"></div><div class="text">正在加载中~</div></div></div><div class="bg"></div><div class="nav-box nav"><div class="nav-name">YATING</div><div class="search-box"><div class="search-key"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAACwUlEQVRYR+3YX+jNdxzH8ccv2vKn1Jokf1qNJDf+TG4MuZBWW4sxf6L8SVlc4ELSciG7GClJZIXMuJCMxZ2yRKKIUGs0LqWmaLYL/3rP5+R0nHO+n+85P/1Ocm7P6/P6PD/v9+fz/rw/3y4d/uvqcD7vAdvN0Dsdwf6YjGH4GPdxD+fxX7uRq4xvJYKfYS1m4BruJrjB+BSj8Ru24Va7oGUAB+InDMJ6XMDTOgAfYiq24npazINWQXMBIzKnsAU/Z04W3huwGrPTgjKHvpblAH6UzOfjaukZXgFuxgTcKTu+CDD+P4MdOFHWvEr/A77EWDwr41ME+F3aT9+WMW2g/R2/YG8Zr2aA/fAXJqbyUca3nnYcTmI4XuSaNQP8CvOwINcsQ3cO3+NshvZ/STPAPTidVp3rV6RbhyGp9BRpCwFjlctxO8spTzQNq/BNnrx5BP/AmAbFONe/VjcC+zAl16BZiv/EeDzONcvQjUyAn2doC1McZWEFIpLd9YsrMEpXdtlqFsFduFjiastZxEZ8gE054qJTPB0rMSfXLEN3E0twKUNbmOJeCMOZqaXK9Wykm5s6nE+6q1DHRFGkv0aYt/Prixup/v1axqjoLg6vqIc7cayMcY12P6IDL71dcgCj3Yo2fiGutAAZXVBcmwPwqOz4HMDwjHfHkdSJHMycJJ4AuzEKDxFd9azubreqWXqnaypOd7w36rX8UUIm4YvUSR9Pde8Jjia4qIHPMxfZ0sM99tLilLbY/DFZnPihKdL/pv36Y82jKTQBGbAxPgsyN8WNFtwndSeRzgCIbvlyk2dnaA4l3aKcctMuYG6mqnUx52FEpJcVQfYEYOUGq0AubbbKngKsQB7AP+kg1eXsScBqyL+xph5hTwNWQ8ZnlO21kJ0AWIGMD1BvfCLpFMCG5+Q9YCuFsrZotuvxVsd3fIpfAk8Fcimtoa6SAAAAAElFTkSuQmCC" class="img"> <input autofocus placeholder="搜索"></div></div></div><div class="all-box"><div class="content-box"><div class="phone-catalog"><div class="phone-box"><span></span></div></div><div class="content"><div class="catalog-box"><div class="catalog-item-big"><div class="catalog-item"><div class="title"></div><div class="article-time"></div></div></div></div><div class="content__default"><h2 id="通用的分代垃圾回收机制"><a href="#通用的分代垃圾回收机制" class="header-anchor">#</a> 通用的分代垃圾回收机制</h2><p>​ 分代垃圾回收机制，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。我们将对象分为三种状态：年轻代、年老代、持久代。JVM将堆内存划分为Eden、Survivor和Tenured/Old空间。</p><ol><li><p>年轻代</p><p>所有新生成的对象首先都是放在Eden区。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象，对应的是Minor GC，每次Minor GC 会清理年轻代的内存，算法采用效率较高的复制算法，频繁的操作，但是会浪费内存空间。当“年轻代”区域存放满对象后，就将对象存放到年老代区域。</p></li><li><p>年老代</p><p>在年轻代中经历了N(默认15)次垃圾回收后仍然存活的对象，就会被放到年老代中。因此可以认为年老代中存放的都是一些生命周期较长的对象。年老代对象越来越多，我们就需要启动Major GC和Full GC(全量回收)，来一次大扫除，全面清理年轻代区域和年老代区域。</p></li><li><p>持久代</p><p>用于存放静态文件，如Java类、方法等。持久代堆垃圾回收没有显著影响。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/mumudadi/cdn@latest/blogImg/java/Garbage.jpg" alt=""></p><ul><li><p>Minor GC：</p><p>用于清理年轻代区域。Eden区满了就会触发一次Minor GC。清理无用对象，将有用对象复制到“Survivor1”、“Survivor2”区中(这两个区，大小空间也相同，同一时刻Surivor1和Surivor2只有一个在用，一个为空)</p></li><li><p>Major GC：</p><p>用于清理年老代区域。</p></li><li><p>Full GC:</p><p>用于清理年轻代、年老代区域。成本较高，会对系统产生影响。</p></li></ul><h3 id="垃圾回收过程："><a href="#垃圾回收过程：" class="header-anchor">#</a> 垃圾回收过程：</h3><ol><li>新创建的对象，绝大多数都会存储在Eden中</li><li>当Eden满了(达到一定比例)不能创建新对象，则触发垃圾回收(GC )，将无用对象清理掉，然后剩余对象赋值到某个Survivor中，如S1，同时清空Eden区</li><li>当Eden区再次满了，会将S1中的不能清空的对象存到另外一个Surivor中，如S2，同时将Eden区中的不能清空的对象，也复制到S2中，保证Eden和S1，均被清空。</li><li>重复多次(默认15次)Survivor中没有被清理的对象，则会复制到老年代Old(Tenured)区中</li><li>当Old区满了，则会出发一个完整地垃圾回收(FullGC)，之前新生代的垃圾回收称为(minorGC)</li></ol><h2 id="jvm调优和full-gc"><a href="#jvm调优和full-gc" class="header-anchor">#</a> JVM调优和Full GC</h2><p>在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节。有如下原因可能导致Full GC：</p><ol><li>年老代(Tenureed)被写满</li><li>持久代(Perm)被写满</li><li>System.gc()被显式调用(程序建议GC启动，不是调用GC)</li><li>上一次GC之后Heap的各域分配策略动态变化</li></ol></div><div class="over">完<div class="block"></div></div><div id="gitalk-container"></div></div><div class="catalog"><div class="level1"></div><a href="#通用的分代垃圾回收机制" nofollow class="level2">通用的分代垃圾回收机制</a><a href="#垃圾回收过程：" nofollow class="level3">垃圾回收过程：</a><a href="#jvm调优和full-gc" nofollow class="level2">JVM调优和Full GC</a></div></div></div><div class="foot">粤ICP备案号：18150247号</div></div><div class="global-ui"></div></div><script src="/vuepress/assets/js/app.6bd1f1a1.js" defer></script><script src="/vuepress/assets/js/7.d0d4b681.js" defer></script><script src="/vuepress/assets/js/12.dfb2ae5e.js" defer></script></body></html>
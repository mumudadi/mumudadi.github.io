"use strict";(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{145:function(v,r,l){l.r(r);var _=l(1),e=Object(_.a)({},function(){var v=this,r=v.$createElement,l=v._self._c||r;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h2",{attrs:{id:"通用的分代垃圾回收机制"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#通用的分代垃圾回收机制"}},[v._v("#")]),v._v(" 通用的分代垃圾回收机制")]),v._v(" "),l("p",[v._v("​        分代垃圾回收机制，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。我们将对象分为三种状态：年轻代、年老代、持久代。JVM将堆内存划分为Eden、Survivor和Tenured/Old空间。")]),v._v(" "),l("ol",[l("li",[l("p",[v._v("年轻代")]),v._v(" "),l("p",[v._v("所有新生成的对象首先都是放在Eden区。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象，对应的是Minor GC，每次Minor GC 会清理年轻代的内存，算法采用效率较高的复制算法，频繁的操作，但是会浪费内存空间。当“年轻代”区域存放满对象后，就将对象存放到年老代区域。")])]),v._v(" "),l("li",[l("p",[v._v("年老代")]),v._v(" "),l("p",[v._v("在年轻代中经历了N(默认15)次垃圾回收后仍然存活的对象，就会被放到年老代中。因此可以认为年老代中存放的都是一些生命周期较长的对象。年老代对象越来越多，我们就需要启动Major GC和Full GC(全量回收)，来一次大扫除，全面清理年轻代区域和年老代区域。")])]),v._v(" "),l("li",[l("p",[v._v("持久代")]),v._v(" "),l("p",[v._v("用于存放静态文件，如Java类、方法等。持久代堆垃圾回收没有显著影响。")])])]),v._v(" "),l("p",[l("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/mumudadi/cdn@latest/blogImg/java/Garbage.jpg",alt:""}})]),v._v(" "),l("ul",[l("li",[l("p",[v._v("Minor GC：")]),v._v(" "),l("p",[v._v("用于清理年轻代区域。Eden区满了就会触发一次Minor GC。清理无用对象，将有用对象复制到“Survivor1”、“Survivor2”区中(这两个区，大小空间也相同，同一时刻Surivor1和Surivor2只有一个在用，一个为空)")])]),v._v(" "),l("li",[l("p",[v._v("Major GC：")]),v._v(" "),l("p",[v._v("用于清理年老代区域。")])]),v._v(" "),l("li",[l("p",[v._v("Full GC:")]),v._v(" "),l("p",[v._v("用于清理年轻代、年老代区域。成本较高，会对系统产生影响。")])])]),v._v(" "),l("h3",{attrs:{id:"垃圾回收过程："}},[l("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收过程："}},[v._v("#")]),v._v(" 垃圾回收过程：")]),v._v(" "),l("ol",[l("li",[v._v("新创建的对象，绝大多数都会存储在Eden中")]),v._v(" "),l("li",[v._v("当Eden满了(达到一定比例)不能创建新对象，则触发垃圾回收(GC )，将无用对象清理掉，然后剩余对象赋值到某个Survivor中，如S1，同时清空Eden区")]),v._v(" "),l("li",[v._v("当Eden区再次满了，会将S1中的不能清空的对象存到另外一个Surivor中，如S2，同时将Eden区中的不能清空的对象，也复制到S2中，保证Eden和S1，均被清空。")]),v._v(" "),l("li",[v._v("重复多次(默认15次)Survivor中没有被清理的对象，则会复制到老年代Old(Tenured)区中")]),v._v(" "),l("li",[v._v("当Old区满了，则会出发一个完整地垃圾回收(FullGC)，之前新生代的垃圾回收称为(minorGC)")])]),v._v(" "),l("h2",{attrs:{id:"jvm调优和full-gc"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#jvm调优和full-gc"}},[v._v("#")]),v._v(" JVM调优和Full GC")]),v._v(" "),l("p",[v._v("在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节。有如下原因可能导致Full GC：")]),v._v(" "),l("ol",[l("li",[v._v("年老代(Tenureed)被写满")]),v._v(" "),l("li",[v._v("持久代(Perm)被写满")]),v._v(" "),l("li",[v._v("System.gc()被显式调用(程序建议GC启动，不是调用GC)")]),v._v(" "),l("li",[v._v("上一次GC之后Heap的各域分配策略动态变化")])])])},[],!1,null,null,null);r.default=e.exports}}]);
{"meta":{"title":"木木","subtitle":null,"description":"好少年光芒万丈","author":"木木","url":"mumudadi.top"},"pages":[{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-12-16T09:23:22.181Z","comments":false,"path":"bangumi/index.html","permalink":"mumudadi.top/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-12-16T16:05:00.170Z","comments":false,"path":"client/index.html","permalink":"mumudadi.top/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-12-16T15:48:11.540Z","comments":true,"path":"comment/index.html","permalink":"mumudadi.top/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-12-16T16:06:24.297Z","comments":false,"path":"donate/index.html","permalink":"mumudadi.top/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-12-16T16:07:19.049Z","comments":false,"path":"lab/index.html","permalink":"mumudadi.top/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-02-03T11:48:09.946Z","comments":false,"path":"music/index.html","permalink":"mumudadi.top/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-12-16T09:23:22.186Z","comments":true,"path":"rss/index.html","permalink":"mumudadi.top/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-12-16T09:23:22.187Z","comments":true,"path":"tags/index.html","permalink":"mumudadi.top/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-12-16T09:23:22.187Z","comments":false,"path":"theme-sakura/index.html","permalink":"mumudadi.top/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-01-11T13:15:18.957Z","comments":false,"path":"about/index.html","permalink":"mumudadi.top/about/index.html","excerpt":"","text":"[さくら荘の木木] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-12-16T09:23:22.188Z","comments":false,"path":"video/index.html","permalink":"mumudadi.top/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-01-18T11:25:30.085Z","comments":true,"path":"links/index.html","permalink":"mumudadi.top/links/index.html","excerpt":"","text":"","keywords":"友人帐"}],"posts":[{"title":"系統接口文檔swagger使用","slug":"Interface","date":"2020-01-10T14:16:01.000Z","updated":"2020-02-04T15:48:32.121Z","comments":true,"path":"2020/01/10/Interface/","link":"","permalink":"mumudadi.top/2020/01/10/Interface/","excerpt":"","text":"在现在的开发过程中还有很大一部分公司都是以口口相传的方式来进行前后端的联调，而接口文档很大一部分都只停留在了说说而已的地步，或者写了代码再写文档。 还有一点就是文档的修改，定义好的接口并不是一成不变的，可能在开发过程中文档修改不止一次的变化，这个时候就会很难受了。 只要不是强制性要求，没人会愿意写这东西，而且在写的过程中，一个字母的错误就会导致联调时候的很大麻烦，但是通过Swagger，我们可以省略了这一步，而且文档出错率近乎于零， 只要你在写代码的时候，稍加几个注解，文档自动生成。 引入依賴&lt;!-- swagger2--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;${swagger.version}&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;io.swagger&lt;/groupId&gt; &lt;artifactId&gt;swagger-annotations&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;io.swagger&lt;/groupId&gt; &lt;artifactId&gt;swagger-models&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--防止进入swagger页面报类型转换错误，排除2.9.2中的引用，手动增加1.5.21版本--&gt; &lt;dependency&gt; &lt;groupId&gt;io.swagger&lt;/groupId&gt; &lt;artifactId&gt;swagger-annotations&lt;/artifactId&gt; &lt;version&gt;1.5.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.swagger&lt;/groupId&gt; &lt;artifactId&gt;swagger-models&lt;/artifactId&gt; &lt;version&gt;1.5.21&lt;/version&gt; &lt;/dependency&gt;Swagger2的接口配置@Configuration @EnableSwagger2 public class SwaggerConfig { /** 系统基础配置 */ @Autowired private RuoYiConfig ruoYiConfig; /** * 创建API */ @Bean public Docket createRestApi() { return new Docket(DocumentationType.SWAGGER_2) // 用来创建该API的基本信息，展示在文档的页面中（自定义展示的信息） .apiInfo(apiInfo()) // 设置哪些接口暴露给Swagger展示 .select() // 扫描所有有注解的api，用这种方式更灵活 .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class)) // 扫描指定包中的swagger注解 //.apis(RequestHandlerSelectors.basePackage(&quot;com.ruoyi.project.tool.swagger&quot;)) // 扫描所有 .apis(RequestHandlerSelectors.any()) .paths(PathSelectors.any()) .build(); } /** * 添加摘要信息 */ private ApiInfo apiInfo() { // 用ApiInfoBuilder进行定制 return new ApiInfoBuilder() // 设置标题 .title(&quot;标题：XX管理系统_接口文档&quot;) // 描述 .description(&quot;描述：用于管理集团旗下公司的人员信息,具体包括XXX,XXX模块...&quot;) // 作者信息 .contact(new Contact(ruoYiConfig.getName(), null, null)) // 版本 .version(&quot;版本号:&quot; + ruoYiConfig.getVersion()) .build(); } } 在控制层Controller中添加注解来描述接口信息如:@Api(&quot;参数配置&quot;) @Controller @RequestMapping(&quot;/system/config&quot;) public class ConfigController在方法中配置接口的标题信息@ApiOperation(&quot;查询参数列表&quot;) @ResponseBody public TableDataInfo list(Config config) { startPage(); List&lt;Config&gt; list = configService.selectConfigList(config); return getDataTable(list); } ApiParam标记，请求属性，使用方式： public TableDataInfo list(@ApiParam(value = &quot;查询用户列表&quot;, required = true)User user)ApiResponse`标记，响应配置，使用方式： @ApiResponse(code = 400, message = &quot;查询用户失败&quot;)訪問 @Controller @RequestMapping(&quot;/tool/swagger&quot;) public class SwaggerController extends BaseController { @RequiresPermissions(&quot;tool:swagger:view&quot;) @GetMapping() public String index() { return redirect(&quot;/swagger-ui.html&quot;); } }","categories":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Interface","slug":"Interface","permalink":"mumudadi.top/tags/Interface/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"PageHelper分頁插件的使用","slug":"PageHelper","date":"2020-01-10T14:16:01.000Z","updated":"2020-02-04T13:33:48.278Z","comments":true,"path":"2020/01/10/PageHelper/","link":"","permalink":"mumudadi.top/2020/01/10/PageHelper/","excerpt":"","text":"使用maven导入jar包這裏使用spring boot整合的pagehelper 自動化配置真香φ(゜▽゜*)♪ &lt;!-- pagehelper 分页插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;${pagehelper.spring.boot.starter.version}&lt;/version&gt; &lt;/dependency&gt;application.yml配置# PageHelper分页插件 pagehelper: helperDialect: mysql reasonable: true supportMethodsArguments: true params: count=countSql 使用：Page page = PageHelper.startPage(pageNum,sizeNum,count); List&lt;MainSearchVo&gt; mainSearchVoList = companyMainPageMapper.getMainSearch(fname);参数详解: pageNum：当前页 sizeNum：每页显示条数 count :是否查询总条数 (true:查询 ，false：不查询) 获取总页数: page.getPages() 獲得縂記錄數：page.getTotal()注意：PageHelper 方法使用了静态的 ThreadLocal 参数，分页参数和线程是绑定的。 只要你可以保证在 PageHelper 方法调用后紧跟 MyBatis 查询方法，这就是安全的。因为 PageHelper 在 finally 代码段中自动清除了 ThreadLocal 存储的对象。如果代码在进入 Executor 前发生异常，就会导致线程不可用，这属于人为的 Bug（例如接口方法和 XML 中的不匹配，导致找不到 MappedStatement 时）， 这种情况由于线程不可用，也不会导致 ThreadLocal 参数被错误的使用。 但是如果你写出下面这样的代码，就是不安全的用法： PageHelper.startPage(1, 10); List&lt;Country&gt; list; if(param1 != null){ list = countryMapper.selectIf(param1); } else { list = new ArrayList&lt;Country&gt;(); } 这种情况下由于 param1 存在 null 的情况，就会导致 PageHelper 生产了一个分页参数，但是没有被消费，这个参数就会一直保留在这个线程上。当这个线程再次被使用时，就可能导致不该分页的方法去消费这个分页参数，这就产生了莫名其妙的分页。 上面这个代码，应该写成下面这个样子： List&lt;Country&gt; list; if(param1 != null){ PageHelper.startPage(1, 10); list = countryMapper.selectIf(param1); } else { list = new ArrayList&lt;Country&gt;(); } 这种写法就能保证安全。第二個坑：Page page = PageHelper.startPage(pageNum,sizeNum,count); Post post = postService.selectPostById(1L); List&lt;User&gt; list = userService.selectUserList(user); 原因分析：只对该语句以后的第一个查询（Select）语句得到的数据进行分页。上面这个代码，应该写成下面这个样子才能正常分页。 Post post = postService.selectPostById(1L); Page page = PageHelper.startPage(pageNum,sizeNum,count); List&lt;User&gt; list = userService.selectUserList(user);","categories":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"PageHelper","slug":"PageHelper","permalink":"mumudadi.top/tags/PageHelper/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"Shiro安全框架使用","slug":"Shiro","date":"2020-01-10T14:16:01.000Z","updated":"2020-02-05T10:07:30.075Z","comments":true,"path":"2020/01/10/Shiro/","link":"","permalink":"mumudadi.top/2020/01/10/Shiro/","excerpt":"","text":"Apache Shiro是Java的一个安全框架。Shiro可以帮助我们完成：认证、授权、加密、会话管理、与Web集成、缓存等。其不仅可以用在 JavaSE环境，也可以用在 JavaEE 环境。 优点 易于理解的 Java Security API 简单的身份认证，支持多种数据源 对角色的简单的授权，支持细粒度的授权 不跟任何的框架或者容器捆绑，可以独立运行 特性 Authentication身份认证/登录，验证用户是不是拥有相应的身份Authorization授权，即验证权限，验证某个已认证的用户是否拥有某个权限，即判断用户是否能做事情 SessionManagement会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中Cryptography加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储Caching缓存，比如用户登录后，其用户信息，拥有的角色/权限不必每次去查，提高效率ConcurrencyShiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播過去 Testing提供测试支持RunAs允许一个用户假装为另一个用户（如果他们允许）的身份进行访问RememberMe记住我，这是非常常见的功能，即一次登录后，下次再来的话不用登录了 架構 Subject主体，代表了当前的“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫， 机器人等；即一个抽象概念；所有Subject都绑定到SercurityManager，与Subject的所有交互都会委托给SecurityManager；可以把Subject认为是一个门面；SecurityManager才是实际的执行者SecurityManage安全管理器；即所有与安全有关的操作都会与SecurityManager交互；且它管理着所有Subject； 可以看出它是Shiro的核心，它负责与后边介绍的其他组件进行交互Realm域，Shiro从Realm获取安全数据（如用户，角色，权限），就是说SecurityManager要验证用户身份， 那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作；可以有1个或多个Realm，我们一般在应用中都需要实现自己的RealmSessionManager如果写过Servlet就应该知道Session的概念，Session需要有人去管理它的生命周期，这个组件就是SessionManagerSessionDAODAO大家都用过，数据库访问对象，用于会话的CRUD，比如我们想把Session保存到数据库，那么可以实现自己的SessionDAO，也可以写入缓存，以提高性能CacheManager缓存控制器，来管理如用户，角色，权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能 应用代码通过Subject来进行认证和授权，而Subject又委托给SecurityManager； 我们需要给Shrio的SecurityManager注入Realm，从而让SecurityManager能得到合法的用户及其权限进行判断，Shiro不提供维护用户/权限，而是通过Realm让开发人员自己注入。 Shiro不会去维护用户，维护权限；这些需要自己去设计/提供；然后通过响应的接口注入给Shiro即可 引入依賴&lt;!--Shiro核心框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;${shiro.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Shiro使用Spring框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;${shiro.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Shiro使用EhCache缓存框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt; &lt;version&gt;${shiro.version}&lt;/version&gt; &lt;/dependency&gt;权限配置加载@Configuration public class ShiroConfig { public static final String PREMISSION_STRING = &quot;perms[\\&quot;{0}\\&quot;]&quot;; // Session超时时间，单位为毫秒（默认30分钟） @Value(&quot;${shiro.session.expireTime}&quot;) private int expireTime; // 相隔多久检查一次session的有效性，单位毫秒，默认就是10分钟 @Value(&quot;${shiro.session.validationInterval}&quot;) private int validationInterval; // 同一个用户最大会话数 @Value(&quot;${shiro.session.maxSession}&quot;) private int maxSession; 。。。。。。。。。。。。。。。。。。 /** * 缓存管理器 使用Ehcache实现 */ @Bean public EhCacheManager getEhCacheManager() { net.sf.ehcache.CacheManager cacheManager = net.sf.ehcache.CacheManager.getCacheManager(&quot;ruoyi&quot;); EhCacheManager em = new EhCacheManager(); if (StringUtils.isNull(cacheManager)) { em.setCacheManager(new net.sf.ehcache.CacheManager(getCacheManagerConfigFileInputStream())); return em; } else { em.setCacheManager(cacheManager); return em; } } /** * 自定义Realm */ @Bean public UserRealm userRealm(EhCacheManager cacheManager) { UserRealm userRealm = new UserRealm(); userRealm.setCacheManager(cacheManager); return userRealm; } /** * 自定义sessionDAO会话 */ @Bean public OnlineSessionDAO sessionDAO() { OnlineSessionDAO sessionDAO = new OnlineSessionDAO(); return sessionDAO; } /** * 自定义sessionFactory会话 */ @Bean public OnlineSessionFactory sessionFactory() { OnlineSessionFactory sessionFactory = new OnlineSessionFactory(); return sessionFactory; } /** * 会话管理器 */ @Bean public OnlineWebSessionManager sessionManager() { OnlineWebSessionManager manager = new OnlineWebSessionManager(); // 加入缓存管理器 manager.setCacheManager(getEhCacheManager()); // 删除过期的session manager.setDeleteInvalidSessions(true); // 设置全局session超时时间 manager.setGlobalSessionTimeout(expireTime * 60 * 1000); // 去掉 JSESSIONID manager.setSessionIdUrlRewritingEnabled(false); // 定义要使用的无效的Session定时调度器 manager.setSessionValidationScheduler(SpringUtils.getBean(SpringSessionValidationScheduler.class)); // 是否定时检查session manager.setSessionValidationSchedulerEnabled(true); // 自定义SessionDao manager.setSessionDAO(sessionDAO()); // 自定义sessionFactory manager.setSessionFactory(sessionFactory()); return manager; } /** * 安全管理器 */ @Bean public SecurityManager securityManager(UserRealm userRealm) { DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); // 设置realm. securityManager.setRealm(userRealm); // 记住我 securityManager.setRememberMeManager(rememberMeManager()); // 注入缓存管理器; securityManager.setCacheManager(getEhCacheManager()); // session管理器 securityManager.setSessionManager(sessionManager()); return securityManager; } /** * Shiro过滤器配置 */ @Bean public ShiroFilterFactoryBean shiroFilterFactoryBean(SecurityManager securityManager) { ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); // Shiro的核心安全接口,这个属性是必须的 shiroFilterFactoryBean.setSecurityManager(securityManager); // 身份认证失败，则跳转到登录页面的配置 shiroFilterFactoryBean.setLoginUrl(loginUrl); // 权限认证失败，则跳转到指定页面 shiroFilterFactoryBean.setUnauthorizedUrl(unauthorizedUrl); // Shiro连接约束配置，即过滤链的定义 LinkedHashMap&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;(); // 对静态资源设置匿名访问 filterChainDefinitionMap.put(&quot;/favicon.ico**&quot;, &quot;anon&quot;); filterChainDefinitionMap.put(&quot;/ruoyi.png**&quot;, &quot;anon&quot;); filterChainDefinitionMap.put(&quot;/css/**&quot;, &quot;anon&quot;); filterChainDefinitionMap.put(&quot;/docs/**&quot;, &quot;anon&quot;); filterChainDefinitionMap.put(&quot;/fonts/**&quot;, &quot;anon&quot;); filterChainDefinitionMap.put(&quot;/img/**&quot;, &quot;anon&quot;); filterChainDefinitionMap.put(&quot;/ajax/**&quot;, &quot;anon&quot;); filterChainDefinitionMap.put(&quot;/js/**&quot;, &quot;anon&quot;); filterChainDefinitionMap.put(&quot;/ruoyi/**&quot;, &quot;anon&quot;); filterChainDefinitionMap.put(&quot;/captcha/captchaImage**&quot;, &quot;anon&quot;); // 退出 logout地址，shiro去清除session filterChainDefinitionMap.put(&quot;/logout&quot;, &quot;logout&quot;); // 不需要拦截的访问 filterChainDefinitionMap.put(&quot;/login&quot;, &quot;anon,captchaValidate&quot;); // 系统权限列表 // filterChainDefinitionMap.putAll(SpringUtils.getBean(IMenuService.class).selectPermsAll()); Map&lt;String, Filter&gt; filters = new LinkedHashMap&lt;String, Filter&gt;(); filters.put(&quot;onlineSession&quot;, onlineSessionFilter()); filters.put(&quot;syncOnlineSession&quot;, syncOnlineSessionFilter()); filters.put(&quot;captchaValidate&quot;, captchaValidateFilter()); filters.put(&quot;kickout&quot;, kickoutSessionFilter()); // 注销成功，则跳转到指定页面 filters.put(&quot;logout&quot;, logoutFilter()); shiroFilterFactoryBean.setFilters(filters); // 所有请求需要认证 filterChainDefinitionMap.put(&quot;/**&quot;, &quot;user,kickout,onlineSession,syncOnlineSession&quot;); shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap); return shiroFilterFactoryBean; } /** * 开启Shiro注解通知器 */ @Bean public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor( @Qualifier(&quot;securityManager&quot;) SecurityManager securityManager) { AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor(); authorizationAttributeSourceAdvisor.setSecurityManager(securityManager); return authorizationAttributeSourceAdvisor; }自定義Realm登錄認證 public class UserRealm extends AuthorizingRealm { @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { UsernamePasswordToken upToken = (UsernamePasswordToken) token; String username = upToken.getUsername(); String password = &quot;&quot;; if (upToken.getPassword() != null) { password = new String(upToken.getPassword()); } User user = null; try { user = loginService.login(username, password); }授權 protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection arg0) { User user = ShiroUtils.getSysUser(); // 角色列表 Set&lt;String&gt; roles = new HashSet&lt;String&gt;(); // 功能列表 Set&lt;String&gt; menus = new HashSet&lt;String&gt;(); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); // 管理员拥有所有权限 if (user.isAdmin()) { info.addRole(&quot;admin&quot;); info.addStringPermission(&quot;*:*:*&quot;); } else { roles = roleService.selectRoleKeys(user.getUserId()); menus = menuService.selectPermsByUserId(user.getUserId()); // 角色加入AuthorizationInfo认证对象 info.setRoles(roles); // 权限加入AuthorizationInfo认证对象 info.setStringPermissions(menus); } return info; }","categories":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"mumudadi.top/tags/Shiro/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"服務端攔截重複提交","slug":"RepeatSubmit","date":"2020-01-10T14:16:01.000Z","updated":"2020-02-07T03:34:12.869Z","comments":true,"path":"2020/01/10/RepeatSubmit/","link":"","permalink":"mumudadi.top/2020/01/10/RepeatSubmit/","excerpt":"","text":"​ 在Web / App项目中，有一些请求或操作会对数据产生影响（比如新增、删除、修改），针对这类请求一般都需要做一些保护，以防止用户有意或无意的重复发起这样的请求导致的数据错乱。 常见处理方案1.客户端 例如表单提交后将提交按钮设为disable 等等方法… 2.服务端 前端的限制仅能解决少部分问题，且不够彻底，后端自有的防重复处理措施必不可少，义不容辞。 在此提供一个我在项目中用到的方案。简单来说就是判断请求url和数据是否和上一次相同。 自定义一个注解 @Inherited @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface RepeatSubmit { } 检查此接口调用的方法是否使用了RepeatSubmit注解，若没有使用，表示此接口不需要校验； 若使用了注解，获取请求url+参数 检查session是否有SESSION_REPEAT_KEY属性，没有直接放行 检查SESSION_REPEAT_KEY屬性值中是否包含url 檢查當前請求request和session中的請求url和參數是否相等 如果不相等就在session中記錄本次請求 @Component public abstract class RepeatSubmitInterceptor extends HandlerInterceptorAdapter { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { if (handler instanceof HandlerMethod) { HandlerMethod handlerMethod = (HandlerMethod) handler; Method method = handlerMethod.getMethod(); RepeatSubmit annotation = method.getAnnotation(RepeatSubmit.class); if (annotation != null) { if (this.isRepeatSubmit(request)) { AjaxResult ajaxResult = AjaxResult.error(&quot;不允许重复提交，请稍后再试&quot;); ServletUtils.renderString(response, JSONObject.toJSONString(ajaxResult)); return false; } } return true; } else { return super.preHandle(request, response, handler); } } /** * 验证是否重复提交由子类实现具体的防重复提交的规则 * * @param httpServletRequest * @return * @throws Exception */ public abstract boolean isRepeatSubmit(HttpServletRequest request); } @Component public class SameUrlDataInterceptor extends RepeatSubmitInterceptor { public final String REPEAT_PARAMS = &quot;repeatParams&quot;; public final String REPEAT_TIME = &quot;repeatTime&quot;; public final String SESSION_REPEAT_KEY = &quot;repeatData&quot;; /** * 间隔时间，单位:秒 默认10秒 * * 两次相同参数的请求，如果间隔时间大于该参数，系统不会认定为重复提交的数据 */ private int intervalTime = 10; public void setIntervalTime(int intervalTime) { this.intervalTime = intervalTime; } @SuppressWarnings(&quot;unchecked&quot;) @Override public boolean isRepeatSubmit(HttpServletRequest request) { // 本次参数及系统时间 String nowParams = JSONObject.toJSONString(request.getParameterMap()); Map&lt;String, Object&gt; nowDataMap = new HashMap&lt;String, Object&gt;(); nowDataMap.put(REPEAT_PARAMS, nowParams); nowDataMap.put(REPEAT_TIME, System.currentTimeMillis()); // 请求地址（作为存放session的key值） String url = request.getRequestURI(); HttpSession session = request.getSession(); Object sessionObj = session.getAttribute(SESSION_REPEAT_KEY); if (sessionObj != null) { Map&lt;String, Object&gt; sessionMap = (Map&lt;String, Object&gt;) sessionObj; if (sessionMap.containsKey(url)) { Map&lt;String, Object&gt; preDataMap = (Map&lt;String, Object&gt;) sessionMap.get(url); if (compareParams(nowDataMap, preDataMap) &amp;&amp; compareTime(nowDataMap, preDataMap)) { return true; } } } Map&lt;String, Object&gt; sessionMap = new HashMap&lt;String, Object&gt;(); sessionMap.put(url, nowDataMap); session.setAttribute(SESSION_REPEAT_KEY, sessionMap); return false; } /** * 判断参数是否相同 */ private boolean compareParams(Map&lt;String, Object&gt; nowMap, Map&lt;String, Object&gt; preMap) { String nowParams = (String) nowMap.get(REPEAT_PARAMS); String preParams = (String) preMap.get(REPEAT_PARAMS); return nowParams.equals(preParams); } /** * 判断两次间隔时间 */ private boolean compareTime(Map&lt;String, Object&gt; nowMap, Map&lt;String, Object&gt; preMap) { long time1 = (Long) nowMap.get(REPEAT_TIME); long time2 = (Long) preMap.get(REPEAT_TIME); if ((time1 - time2) &lt; (this.intervalTime * 1000)) { return true; } return false; } } 注册拦截器","categories":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Repeat","slug":"Repeat","permalink":"mumudadi.top/tags/Repeat/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"防範XSS攻擊","slug":"XSS","date":"2020-01-10T14:16:01.000Z","updated":"2020-02-05T15:01:10.888Z","comments":true,"path":"2020/01/10/XSS/","link":"","permalink":"mumudadi.top/2020/01/10/XSS/","excerpt":"","text":"XSS : 跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意攻击用户的特殊目的。过滤方式:主要通过对html标签进行转义的方式达到过滤的目的 過濾器配置@Configuration public class FilterConfig { @Value(&quot;${xss.enabled}&quot;) private String enabled; @Value(&quot;${xss.excludes}&quot;) private String excludes; @Value(&quot;${xss.urlPatterns}&quot;) private String urlPatterns; @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; }) @Bean public FilterRegistrationBean xssFilterRegistration() { FilterRegistrationBean registration = new FilterRegistrationBean(); registration.setDispatcherTypes(DispatcherType.REQUEST); registration.setFilter(new XssFilter()); registration.addUrlPatterns(StringUtils.split(urlPatterns, &quot;,&quot;)); registration.setName(&quot;xssFilter&quot;); registration.setOrder(Integer.MAX_VALUE); Map&lt;String, String&gt; initParameters = Maps.newHashMap(); initParameters.put(&quot;excludes&quot;, excludes); initParameters.put(&quot;enabled&quot;, enabled); registration.setInitParameters(initParameters); return registration; } } 自定義過濾器編寫public class XssFilter implements Filter { /** * 排除链接 */ public List&lt;String&gt; excludes = new ArrayList&lt;&gt;(); /** * xss过滤开关 */ public boolean enabled = false; @Override public void init(FilterConfig filterConfig) throws ServletException { String tempExcludes = filterConfig.getInitParameter(&quot;excludes&quot;); String tempEnabled = filterConfig.getInitParameter(&quot;enabled&quot;); if (StringUtils.isNotEmpty(tempExcludes)) { String[] url = tempExcludes.split(&quot;,&quot;); for (int i = 0; url != null &amp;&amp; i &lt; url.length; i++) { excludes.add(url[i]); } } if (StringUtils.isNotEmpty(tempEnabled)) { enabled = Boolean.valueOf(tempEnabled); } } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse resp = (HttpServletResponse) response; if (handleExcludeURL(req, resp)) { chain.doFilter(request, response); return; } XssHttpServletRequestWrapper xssRequest = new XssHttpServletRequestWrapper((HttpServletRequest) request); chain.doFilter(xssRequest, response); } private boolean handleExcludeURL(HttpServletRequest request, HttpServletResponse response) { if (!enabled) { return true; } if (excludes == null || excludes.isEmpty()) { return false; } String url = request.getServletPath(); for (String pattern : excludes) { Pattern p = Pattern.compile(&quot;^&quot; + pattern); Matcher m = p.matcher(url); if (m.find()) { return true; } } return false; }過濾處理實現public class XssHttpServletRequestWrapper extends HttpServletRequestWrapper { /** * @param request */ public XssHttpServletRequestWrapper(HttpServletRequest request) { super(request); } @Override public String[] getParameterValues(String name) { String[] values = super.getParameterValues(name); if (values != null) { int length = values.length; String[] escapseValues = new String[length]; for (int i = 0; i &lt; length; i++) { // 防xss攻击和过滤前后空格 escapseValues[i] = EscapeUtil.clean(values[i]).trim(); } return escapseValues; } return super.getParameterValues(name); } }","categories":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"mumudadi.top/tags/XSS/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"Spring Security做JWT认证和授权","slug":"SpringSecurity-JWT","date":"2020-01-10T14:16:01.000Z","updated":"2020-02-08T04:15:02.502Z","comments":true,"path":"2020/01/10/SpringSecurity-JWT/","link":"","permalink":"mumudadi.top/2020/01/10/SpringSecurity-JWT/","excerpt":"","text":"JWT是一个含签名并携带用户相关信息的加密串，页面请求校验登录接口时，请求头中携带JWT串到后端服务，后端通过签名加密串匹配校验，保证信息未被篡改。校验通过则认为是可靠的请求，将正常返回数据。 ​ Spring Security是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。 spring-security中核心概念 AuthenticationManager, 用户认证的管理类，所有的认证请求（比如login）都会通过提交一个token给AuthenticationManager的authenticate()方法来实现。当然事情肯定不是它来做，具体校验动作会由AuthenticationManager将请求转发给具体的实现类来做。根据实现反馈的结果再调用具体的Handler来给用户以反馈。这个类基本等同于shiro的SecurityManager。 AuthenticationProvider, 认证的具体实现类，一个provider是一种认证方式的实现，比如提交的用户名密码我是通过和DB中查出的user记录做比对实现的，那就有一个DaoProvider；如果我是通过CAS请求单点登录系统实现，那就有一个CASProvider。这个是不是和shiro的Realm的定义很像？基本上你可以帮他们当成同一个东西。按照Spring一贯的作风，主流的认证方式它都已经提供了默认实现，比如DAO、LDAP、CAS、OAuth2等。前面讲了AuthenticationManager只是一个代理接口，真正的认证就是由AuthenticationProvider来做的。一个AuthenticationManager可以包含多个Provider，每个provider通过实现一个support方法来表示自己支持那种Token的认证。AuthenticationManager默认的实现类是ProviderManager。 UserDetailService, 用户认证通过Provider来做，所以Provider需要拿到系统已经保存的认证信息，获取用户信息的接口spring-security抽象成UserDetailService。虽然叫Service,但是我更愿意把它认为是我们系统里经常有的UserDao。 AuthenticationToken, 所有提交给AuthenticationManager的认证请求都会被封装成一个Token的实现，比如最容易理解的UsernamePasswordAuthenticationToken。这个就不多讲了，连名字都跟Shiro中一样。 SecurityContext，当用户通过认证之后，就会为这个用户生成一个唯一的SecurityContext，里面包含用户的认证信息Authentication。通过SecurityContext我们可以获取到用户的标识Principle和授权信息GrantedAuthrity。在系统的任何地方只要通过SecurityHolder.getSecruityContext()就可以获取到SecurityContext。在Shiro中通过SecurityUtils.getSubject()到达同样的目的。 JWT认证的实现支持用户通过用户名和密码登录 登录后通过http header返回token，每次请求，客户端需通过header将token带回，用于权限校验 服务端负责token的定期刷新 引入相关依赖&lt;!-- spring security 安全认证 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--Token生成与解析--&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;${jwt.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- redis 缓存操作 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt;登录认证流程* spring security配置 @EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true) public class SecurityConfig extends WebSecurityConfigurerAdapter { /** * 自定义用户认证逻辑 */ @Autowired private UserDetailsService userDetailsService; /** * anyRequest | 匹配所有请求路径 * access | SpringEl表达式结果为true时可以访问 * anonymous | 匿名可以访问 * denyAll | 用户不能访问 * fullyAuthenticated | 用户完全认证可以访问（非remember-me下自动登录） * hasAnyAuthority | 如果有参数，参数表示权限，则其中任何一个权限可以访问 * hasAnyRole | 如果有参数，参数表示角色，则其中任何一个角色可以访问 * hasAuthority | 如果有参数，参数表示权限，则其权限可以访问 * hasIpAddress | 如果有参数，参数表示IP地址，如果用户IP和参数匹配，则可以访问 * hasRole | 如果有参数，参数表示角色，则其角色可以访问 * permitAll | 用户可以任意访问 * rememberMe | 允许通过remember-me登录的用户访问 * authenticated | 用户登录后可访问 */ @Override protected void configure(HttpSecurity httpSecurity) throws Exception { httpSecurity // CRSF禁用，因为不使用session .csrf().disable() // 认证失败处理类 .exceptionHandling().authenticationEntryPoint(unauthorizedHandler).and() // 基于token，所以不需要session .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and() // 过滤请求 .authorizeRequests() // 对于登录login 验证码captchaImage 允许匿名访问 .antMatchers(&quot;/login&quot;, &quot;/captchaImage&quot;).anonymous() .antMatchers( HttpMethod.GET, &quot;/*.html&quot;, &quot;/**/*.html&quot;, &quot;/**/*.css&quot;, &quot;/**/*.js&quot; ).permitAll() .antMatchers(&quot;/profile/**&quot;).anonymous() .antMatchers(&quot;/common/download**&quot;).anonymous() .antMatchers(&quot;/swagger-ui.html&quot;).anonymous() .antMatchers(&quot;/swagger-resources/**&quot;).anonymous() .antMatchers(&quot;/webjars/**&quot;).anonymous() .antMatchers(&quot;/*/api-docs&quot;).anonymous() .antMatchers(&quot;/druid/**&quot;).anonymous() // 除上面外的所有请求全部需要鉴权认证 .anyRequest().authenticated() .and() .headers().frameOptions().disable(); httpSecurity.logout().logoutUrl(&quot;/logout&quot;).logoutSuccessHandler(logoutSuccessHandler); // 添加JWT filter httpSecurity.addFilterBefore(authenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); } /** * 强散列哈希加密实现 */ @Bean public BCryptPasswordEncoder bCryptPasswordEncoder() { return new BCryptPasswordEncoder(); } /** * 身份认证接口 */ @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userDetailsService).passwordEncoder(bCryptPasswordEncoder()); } }封装后的token最终是交给provider来处理的。对于登录的provider，spring security已经提供了一个默认实现DaoAuthenticationProvider我们可以直接使用，这个类继承了AbstractUserDetailsAuthenticationProvider我们来看下关键部分的源代码是怎么做的 public abstract class AbstractUserDetailsAuthenticationProvider implements AuthenticationProvider, InitializingBean, MessageSourceAware { ... //这个方法返回true，说明支持该类型的token public boolean supports(Class&lt;?&gt; authentication) { return (UsernamePasswordAuthenticationToken.class .isAssignableFrom(authentication)); } public Authentication authenticate(Authentication authentication) throws AuthenticationException { ... try { // 获取系统中存储的用户信息 user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication); } catch (UsernameNotFoundException notFound) { logger.debug(&quot;User &#39;&quot; + username + &quot;&#39; not found&quot;); if (hideUserNotFoundExceptions) { throw new BadCredentialsException(messages.getMessage( &quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;)); } else { throw notFound; } } } try { //检查user是否已过期或者已锁定 preAuthenticationChecks.check(user); //将获取到的用户信息和登录信息做比对 additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication); } catch (AuthenticationException exception) { ... throw exception; } ... //如果认证通过，则封装一个AuthenticationInfo, 放到SecurityContext中 return createSuccessAuthentication(principalToReturn, authentication, user); } ... }上面的代码中，核心流程就是retrieveUser()获取系统中存储的用户信息，再对用户信息做了过期和锁定等校验后交给additionalAuthenticationChecks()和用户提交的信息做比对。 这两个方法我们看他的继承类DaoAuthenticationProvider是怎么实现的。 public class DaoAuthenticationProvider extends AbstractUserDetailsAuthenticationProvider { /** * 加密密码比对 */ protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException { if (authentication.getCredentials() == null) { logger.debug(&quot;Authentication failed: no credentials provided&quot;); throw new BadCredentialsException(messages.getMessage( &quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;)); } String presentedPassword = authentication.getCredentials().toString(); if (!passwordEncoder.matches(presentedPassword, userDetails.getPassword())) { logger.debug(&quot;Authentication failed: password does not match stored value&quot;); throw new BadCredentialsException(messages.getMessage( &quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;)); } } /** * 系统用户获取 */ protected final UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException { prepareTimingAttackProtection(); try { UserDetails loadedUser = this.getUserDetailsService().loadUserByUsername(username); if (loadedUser == null) { throw new InternalAuthenticationServiceException( &quot;UserDetailsService returned null, which is an interface contract violation&quot;); } return loadedUser; } catch (UsernameNotFoundException ex) { mitigateAgainstTimingAttack(authentication); throw ex; } catch (InternalAuthenticationServiceException ex) { throw ex; } catch (Exception ex) { throw new InternalAuthenticationServiceException(ex.getMessage(), ex); } } }上面的方法实现中，用户获取是调用了UserDetailsService来完成的。这个是一个只有一个方法的接口，所以我们自己要做的，就是将自己的UserDetailsService实现类配置成一个Bean。 @Service public class UserDetailsServiceImpl implements UserDetailsService { private static final Logger log = LoggerFactory.getLogger(UserDetailsServiceImpl.class); @Autowired private ISysUserService userService; @Autowired private SysPermissionService permissionService; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { SysUser user = userService.selectUserByUserName(username); if (StringUtils.isNull(user)) { log.info(&quot;登录用户：{} 不存在.&quot;, username); throw new UsernameNotFoundException(&quot;登录用户：&quot; + username + &quot; 不存在&quot;); } else if (UserStatus.DELETED.getCode().equals(user.getDelFlag())) { log.info(&quot;登录用户：{} 已被删除.&quot;, username); throw new BaseException(&quot;对不起，您的账号：&quot; + username + &quot; 已被删除&quot;); } else if (UserStatus.DISABLE.getCode().equals(user.getStatus())) { log.info(&quot;登录用户：{} 已被停用.&quot;, username); throw new BaseException(&quot;对不起，您的账号：&quot; + username + &quot; 已停用&quot;); } return createLoginUser(user); } public UserDetails createLoginUser(SysUser user) { return new LoginUser(user, permissionService.getMenuPermission(user)); } }认证结果处理认证失败处理 @Component public class AuthenticationEntryPointImpl implements AuthenticationEntryPoint, Serializable { private static final long serialVersionUID = -8970718410437077606L; @Override public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException { int code = HttpStatus.UNAUTHORIZED; String msg = StringUtils.format(&quot;请求访问：{}，认证失败，无法访问系统资源&quot;, request.getRequestURI()); ServletUtils.renderString(response, JSON.toJSONString(AjaxResult.error(code, msg))); } }带Token请求校验流程用户除登录之外的请求，都要求必须携带JWT Token。所以我们需要另外一个Filter对这些请求做一个拦截。这个拦截器主要是提取header中的token，跟登录一样，提交给AuthenticationManager做检查。 //token过滤器 验证token有效性 @Component public class JwtAuthenticationTokenFilter extends OncePerRequestFilter { @Autowired private TokenService tokenService; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException { LoginUser loginUser = tokenService.getLoginUser(request); if (StringUtils.isNotNull(loginUser) &amp;&amp; StringUtils.isNull(SecurityUtils.getAuthentication())) { tokenService.verifyToken(loginUser); UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser, null, loginUser.getAuthorities()); authenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request)); SecurityContextHolder.getContext().setAuthentication(authenticationToken); } chain.doFilter(request, response); } }","categories":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JWT","slug":"JWT","permalink":"mumudadi.top/tags/JWT/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"Springboot參數校驗hibernate-validator","slug":"hibernate-validator","date":"2020-01-10T14:16:01.000Z","updated":"2020-02-06T03:27:33.052Z","comments":true,"path":"2020/01/10/hibernate-validator/","link":"","permalink":"mumudadi.top/2020/01/10/hibernate-validator/","excerpt":"","text":"在开发JAVA服务器端代码时，我们会遇到对外部传来的参数合法性进行验证，而hibernate-validator提供了一些常用的参数校验注解，我们可以拿来使用。 避免過多使用if判空導致代碼沉積public class SysDept extends BaseEntity { 。。。。。。。。。。。。。。 @NotBlank(message = &quot;部门名称不能为空&quot;) @Size(min = 0, max = 30, message = &quot;部门名称长度不能超过30个字符&quot;) public String getDeptName() { return deptName; } 。。。。。。。。。。。。。。也可以寫在屬性上 /** 部门名称 */ @NotBlank(message = &quot;部门名称不能为空&quot;) private String deptName;測試結果 {&quot;msg&quot;:&quot;部门名称不能为空&quot;,&quot;code&quot;:500}","categories":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"hibernate-validator","slug":"hibernate-validator","permalink":"mumudadi.top/tags/hibernate-validator/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"定時任務quartz使用","slug":"quartz","date":"2020-01-10T14:16:01.000Z","updated":"2020-02-04T14:55:23.887Z","comments":true,"path":"2020/01/10/quartz/","link":"","permalink":"mumudadi.top/2020/01/10/quartz/","excerpt":"","text":"​ 在实际项目开发中Web应用有一类不可缺少的，那就是定时任务。 定时任务的场景可以说非常广泛，比如某些视频网站，购买会员后，每天会给会员送成长值，每月会给会员送一些电影券； 比如在保证最终一致性的场景中，往往利用定时任务调度进行一些比对工作；比如一些定时需要生成的报表、邮件；比如一些需要定时清理数据的任务等。 所以我们提供方便友好的web界面，实现动态管理任务，可以达到动态控制定时任务启动、暂停、重启、删除、添加、修改等操作，极大地方便了开发过程。 添加依賴&lt;!-- 定时任务 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;定時任務調度類@Component(&quot;ryTask&quot;) public class RyTask { public void ryMultipleParams(String s, Boolean b, Long l, Double d, Integer i) { System.out.println(StringUtils.format(&quot;执行多参方法： 字符串类型{}，布尔类型{}，长整型{}，浮点型{}，整形{}&quot;, s, b, l, d, i)); } public void ryParams(String params) { System.out.println(&quot;执行有参方法：&quot; + params); } public void ryNoParams() { System.out.println(&quot;执行无参方法&quot;); } }定時任務工具類public class ScheduleUtils { /** * 得到quartz任务类 * * @param sysJob 执行计划 * @return 具体执行任务类 */ private static Class&lt;? extends org.quartz.Job&gt; getQuartzJobClass(Job job) { boolean isConcurrent = &quot;0&quot;.equals(job.getConcurrent()); return isConcurrent ? QuartzJobExecution.class : QuartzDisallowConcurrentExecution.class; } /** * 构建任务触发对象 */ public static TriggerKey getTriggerKey(Long jobId, String jobGroup) { return TriggerKey.triggerKey(ScheduleConstants.TASK_CLASS_NAME + jobId, jobGroup); } /** * 构建任务键对象 */ public static JobKey getJobKey(Long jobId, String jobGroup) { return JobKey.jobKey(ScheduleConstants.TASK_CLASS_NAME + jobId, jobGroup); } /** * 创建定时任务 */ public static void createScheduleJob(Scheduler scheduler, Job job) throws SchedulerException, TaskException { Class&lt;? extends org.quartz.Job&gt; jobClass = getQuartzJobClass(job); // 构建job信息 Long jobId = job.getJobId(); String jobGroup = job.getJobGroup(); JobDetail jobDetail = JobBuilder.newJob(jobClass).withIdentity(getJobKey(jobId, jobGroup)).build(); // 表达式调度构建器 CronScheduleBuilder cronScheduleBuilder = CronScheduleBuilder.cronSchedule(job.getCronExpression()); cronScheduleBuilder = handleCronScheduleMisfirePolicy(job, cronScheduleBuilder); // 按新的cronExpression表达式构建一个新的trigger CronTrigger trigger = TriggerBuilder.newTrigger().withIdentity(getTriggerKey(jobId, jobGroup)) .withSchedule(cronScheduleBuilder).build(); // 放入参数，运行时的方法可以获取 jobDetail.getJobDataMap().put(ScheduleConstants.TASK_PROPERTIES, job); // 判断是否存在 if (scheduler.checkExists(getJobKey(jobId, jobGroup))) { // 防止创建时存在数据问题 先移除，然后在执行创建操作 scheduler.deleteJob(getJobKey(jobId, jobGroup)); } scheduler.scheduleJob(jobDetail, trigger); // 暂停任务 if (job.getStatus().equals(ScheduleConstants.Status.PAUSE.getValue())) { scheduler.pauseJob(ScheduleUtils.getJobKey(jobId, jobGroup)); } } /** * 设置定时任务策略 */ public static CronScheduleBuilder handleCronScheduleMisfirePolicy(Job job, CronScheduleBuilder cb) throws TaskException { switch (job.getMisfirePolicy()) { case ScheduleConstants.MISFIRE_DEFAULT: return cb; case ScheduleConstants.MISFIRE_IGNORE_MISFIRES: return cb.withMisfireHandlingInstructionIgnoreMisfires(); case ScheduleConstants.MISFIRE_FIRE_AND_PROCEED: return cb.withMisfireHandlingInstructionFireAndProceed(); case ScheduleConstants.MISFIRE_DO_NOTHING: return cb.withMisfireHandlingInstructionDoNothing(); default: throw new TaskException(&quot;The task misfire policy &#39;&quot; + job.getMisfirePolicy() + &quot;&#39; cannot be used in cron schedule tasks&quot;, Code.CONFIG_ERROR); } } }定時任務調度表 回復任務調度 @Override @Transactional public int resumeJob(Job job) throws SchedulerException { Long jobId = job.getJobId(); String jobGroup = job.getJobGroup(); job.setStatus(ScheduleConstants.Status.NORMAL.getValue()); int rows = jobMapper.updateJob(job); if (rows &gt; 0) { scheduler.resumeJob(ScheduleUtils.getJobKey(jobId, jobGroup)); } return rows; }暫停任務 scheduler.pauseJob(ScheduleUtils.getJobKey(jobId, jobGroup));執行一次 // 参数 JobDataMap dataMap = new JobDataMap(); dataMap.put(ScheduleConstants.TASK_PROPERTIES, properties); scheduler.triggerJob(ScheduleUtils.getJobKey(jobId, jobGroup), dataMap);","categories":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"quartz","slug":"quartz","permalink":"mumudadi.top/tags/quartz/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"java面试题整理","slug":"InterviewQuestion","date":"2020-01-09T09:16:01.000Z","updated":"2020-02-04T14:40:47.925Z","comments":true,"path":"2020/01/09/InterviewQuestion/","link":"","permalink":"mumudadi.top/2020/01/09/InterviewQuestion/","excerpt":"","text":"HashMap的key存对象的时候，需要注意什么 如果自定义对象作为Map的键，那么必须重写hashCode和equals方法 绕口令式hashCode与equals 如果两对象equals()是true,那么它们的hashCode()值一定相等 如果两对象的hashCode()值相等，它们的equals不一定相等（hash冲突啦） 总结： ​ 1.hashCode()在散列表中才有用，在其他情况下没用 ​ 2.哈希值冲突了场景，hashCode相等，但equals不等 ​ 3.hashCode: 计算键的hashcode作为存储键信息的数组下标用于查找键对象的存储位置 ​ 4.equals：HashMap使用equals()判断当前的键是否与表中存在的键相同。 java异常种类，具体怎么用项目里 先定义一个异常码枚举处理 public enum ErrorCodeEnum { SYS_ERROR(&quot;SYS_ERROR&quot;, &quot;系统错误，请重试&quot;), UNKNOWN_ERROR(&quot;UNKNOWN_SYS_ERROR&quot;, &quot;未知的系统异常&quot;), SERVICE_INVOKE_FAIL(&quot;SERVICE_INVOKE_FAIL&quot;, &quot;服务调用失败&quot;), ILLEGAL_ARGS(&quot;ILLEGAL_ARGS&quot;, &quot;参数校验错误&quot;) 枚举构造函数 /** * 结果码值. */ private String code; /** * 描述. */ private String desc; ErrorCodeEnum(String code, String desc) { this.code = code; this.desc = desc; } 一个通过code找枚举的方法 public static ErrorCodeEnum getByValue(String code) { for (ErrorCodeEnum result : values()) { System.out.println(result.ordinal()); if (StringUtils.equals(result.getCode(), code)) { return result; } } return null; }自定义异常 注意有个异常枚举 继承了RuntimeException public class TestException extends RuntimeException { private static final long serialVersionUID = -8581672033133636908L; /*** 错误码枚举*/ private ErrorCodeEnum errorCode; 总结 定义异常码类就可以，如果业务非常复杂可以把异常码类多搞几个出来 项目中一个异常类够用了，通过不同异常码定义去区分业务异常 强烈建议开发时多定义异常码，越细越好，上了生产方便快速定位BUG 关键枚举异常码+自定义异常 接口联调问题案例互联网项目接口联调非常重要，今天和这个系统对接明天又换了一家公司对接，联调的时候会遇到各种问题 编码问题gbk、utf-8 不说了最简单的也最容易乱码的问题 环境不通 ping 命令 curl 命令可以帮到你，联调前一代要检查下环境 数据格式转换异常，接口文档没看清楚给了错误的格式，粗心问题 Java设计模式思想（单例模式，工厂模式，策略模式）​ 单例模式：单例模式核心只需要new一个实例对象的模式，比如数据库连接，在线人数等，一些网站上看到的在线人数统计就是通过单例模式实现的，把一个计时器存放在数据库或者内存中，当有人登陆的时候取出来加一再放回去，有人退出登陆的时候取出来减一再放回去，但是当有两个人同时登陆的时候，会同时取出计数器，同时加一，同时放回去，这样的话数据就会错误，所以需要一个全局变量的对象给全部人使用，只需要new出一个实例对象，这就是单例模式的应用，并且单例模式节省资源，因为它控制了实例对象的个数，并有利于gc回收。 ​ 策略模式：就是将几个类中公共的方法提取到一个新的类中，从而使扩展更容易，保证代码的可移植性，可维护性强。比如有个需求是写鸭子对象，鸭子有叫，飞，外形这三种方法，如果每个鸭子类都写这三个方法会出现代码的冗余，这时候我们可以把鸭子中的叫，飞，外形这三个方法提取出来，放到鸭父类中，让每个鸭子都继承这个鸭父类，重写这三个方法，这样封装的代码可移植性强，当用户提出新的需求比如鸭子会游泳，那么对于我们oo程序员来讲就非常简单了我们只需要在鸭父类中加一个游泳的方法，让会游泳的鸭子重写游泳方法就可以了。 ​ 工厂模式：简单的工厂模式主要是统一提供实例对象的引用，通过工厂模式接口获取实例对象的引用。比如一个登陆功能，后端有三个类，controller类，interface类，实现接口的实现类。当客户端发出一个请求，当请求传到controller类中时，controller获取接口的引用对象，而实现接口的实现类中封装好了登陆的业务逻辑代码。当你需要加一个注册需求的时候只需要在接口类中加一个注册方法，实现类中实现方法，controller获取接口的引用对象即可，不需要改动原来的代码，这种做法是的可拓展性强。 SpringMVC主流程 1、用户发送请求至前端控制器DispatcherServlet。 2、DispatcherServlet收到请求调用HandlerMapping处理器映射器。 3、处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 4、 DispatcherServlet调用HandlerAdapter处理器适配器。 5、HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 6、Controller执行完成返回ModelAndView。 7、HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 8、DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 9、ViewReslover解析后返回具体View. 10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 11、DispatcherServlet响应用户。 SpringAOP/IOC1.理解“控制反转“ 控制反转，也称为依赖注入，是面向对象编程中的一种设计理念，用来降低程序代码之间的耦合度。 程序的耦合： 调用者与被调用者的依赖关系 比如：程序员A负责编写A类，程序员B负责B类开发，A类的某些功能需要实例化B类的对象调用其方法才能完成，那么A类就依赖B类，如果程序员B不写B类 难道程序员A要一直等下去吗？ 企业开发的原则： &quot;编译时不依赖，运行时才依赖&quot; 理解“面向切面编程” 那么什么是面向切面编程呢？比如在两个类中，可能都需要在每个方法中记录日志。按照面向对象的设计方法，我们就必须在两个类的方法中都加入日志的内容。也许他们是完全相同的，但就是因为面向对象的设计让类与类之间无法联系，而不能将这些重复的代码统一起来。 也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。 4种分布式session解决方案直接将信息存储在cookie中cookie是存储在客户端上的一小段数据，客户端通过http协议和服务器进行cookie交互，通常用来存储一些不敏感信息 缺点： ​ 数据存储在客户端，存在安全隐患​ cookie存储大小、类型存在限制​ 数据存储在cookie中，如果一次请求cookie过大，会给网络增加更大的开销 session复制 session复制是小型企业应用使用较多的一种服务器集群session管理机制，在真正的开发使用的并不是很多，通过对web服务器(例如Tomcat)进行搭建集群。 存在的问题： session同步的原理是在同一个局域网里面通过发送广播来异步同步session的，一旦服务器多了，并发上来了，session需要同步的数据量就大了，需要将其他服务器上的session全部同步到本服务器上，会带来一定的网路开销，在用户量特别大的时候，会出现内存不足的情况优点： 服务器之间的session信息都是同步的，任何一台服务器宕机的时候不会影响另外服务器中session的状态，配置相对简单Tomcat内部已经支持分布式架构开发管理机制，可以对tomcat修改配置来支持session复制，在集群中的几台服务器之间同步session对象，使每台服务器上都保存了所有用户的session信息，这样任何一台本机宕机都不会导致session数据的丢失，而服务器使用session时，也只需要在本机获取即可 session绑定： 利用nginx的反向代理和负载均衡，之前是客户端会被分配到其中一台服务器进行处理，具体分配到哪台服务器进行处理还得看服务器的负载均衡算法(轮询、随机、ip-hash、权重等)，但是我们可以基于nginx的ip-hash策略，可以对客户端和服务器进行绑定，同一个客户端就只能访问该服务器，无论客户端发送多少次请求都被同一个服务器处理缺点： 容易造成单点故障，如果有一台服务器宕机，那么该台服务器上的session信息将会丢失 前端不能有负载均衡，如果有，session绑定将会出问题 优点： 配置简单 基于redis存储session方案 优点： 这是企业中使用的最多的一种方式spring为我们封装好了spring-session，直接引入依赖即可数据保存在redis中，无缝接入，不存在任何安全隐患redis自身可做集群，搭建主从，同时方便管理缺点： 多了一次网络调用，web容器需要向redis访问总结：一般会将web容器所在的服务器和redis所在的服务器放在同一个机房，减少网络开销，走内网进行连接 浅析 Comparable和 Comparator的区别Comparable可以认为是一个内比较器，实现了Comparable接口的类有一个特点，就是这些 类是可以和自己比较的，至于具体和另一个实现了Comparable接口的类如何比较，则依赖compareTo方法的实现，compareTo方法也被称为自然比较方法。如果开发者add进入一个Collection的对象想要Collections的sort方法帮你自动进行排序的话，那么这个对象必须实现Comparable接口。compareTo方法的返回值是int，有三种情况： 1、比较者大于被比较者（也就是compareTo方法里面的对象），那么返回正整数2、比较者等于被比较者，那么返回03、比较者小于被比较者，那么返回负整数 Comparator可以认为是是一个外比较器，个人认为有两种情况可以使用实现Comparator接口的方式：1、一个对象不支持自己和自己比较（没有实现Comparable接口），但是又想对两个对象进行比较。2、一个对象实现了Comparable接口，但是开发者认为compareTo方法中的比较方式并不是自己想要的那种比较方式。Comparator接口里面有一个compare方法，方法有两个参数T o1和T o2，是泛型的表示方式，分别表示待比较的两个对象，方法返回值和Comparable接口一样是int，有三种情况： 1、o1大于o2，返回正整数 2、o1等于o2，返回0 3、o1小于o3，返回负整数 这两种比较器Comparable和Comparator，后者相比前者有如下优点： 个性化比较：如果实现类没有实现Comparable接口，又想对两个类进行比较（或者实现类实现了Comparable接口，但是对compareTo方法内的比较算法不满意），那么可以实现Comparator接口，自定义一个比较器，写比较算法。解耦：实现Comparable接口的方式比实现Comparator接口的耦合性要强一些，如果要修改比较算法，要修改Comparable接口的实现类，而实现Comparator的类是在外部进行比较的，不需要对实现类有任何修改。从这个角度说，其实有些不太好，尤其在我们将实现类的.class文件打成一个.jar文件提供给开发者使用的时候。 Collections 工具类常用方法:排序操作 void reverse(List list)//反转 void shuffle(List list)//随机排序 void sort(List list)//按自然排序的升序排序 void sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑 void swap(List list, int i , int j)//交换两个索引位置的元素 void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面。 查找,替换操作 int binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的 int max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll) int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c) void fill(List list, Object obj)//用指定的元素代替指定list中的所有元素。 int frequency(Collection c, Object o)//统计元素出现次数 int indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target). boolean replaceAll(List list, Object oldVal, Object newVal), 用新元素替换旧元素 String，StringBuffer，StringBuilder的区别下楼梯回答：分别从 线程安全 ​ 执行效率 ​ 存储空间 ​ 使用场景 线程安全性： ​ 线程安全 String 、StringBuffer ​ 非线程安全 StringBuilder 执行效率： StringBuilder &gt; StringBuffer &gt; String 存储空间： String 的值是不可变的，每次对String的操作都会生成新的String对象， 效率低耗费大量内存空间，从而引起GC。 StringBuffer和StringBuilder都是可变。 使用场景： 1如果要操作少量的数据用 String 2.单线程操作字符串缓冲区 下操作大量数据 = StringBuilder 3.多线程操作字符串缓冲区 下操作大量数据 = StringBuffer HashMap的考察下楼梯大法 存储结构 ​ 默认容量 ​ 装载因子 ​ hashcode/equals ​ 1.7和1.8版本变化 1.内部存储结构：数组+链表+红黑树（JDK8） 2.默认容量16，默认装载因子0.75。 3.key和value对数据类型的要求都是泛型。 4.key可以为null，放在table[0]中。 5.hashcode：计算键的hashcode作为存储键信息的数组下标用于查找键对象的存储位置。equals：HashMap使用equals()判断当前的键是否与表中存在的键相同。 为什么要设计出迭代器 迭代器本质是一种设计模式，为了解决为不同的集合类提供统一的遍历操作接口。 java单机并发控制1.同步方法synchronized 2.同步块synchronized 3 可重入锁 ReentrantLock ，指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，而其他的线程是不可以的。 多线程创建的方式1、继承Thread类创建线程 2、实现Runnable接口创建线程 3、实现Callable接口通过FutureTask包装器来创建Thread线程 4、使用ExecutorService、Callable、Future实现有返回结果的线程 一般说出这3种，并把区别说下即可 Thread ​ Runnable ​ Callable (1)Callable规定的方法是call(),Runnable规定的方法是run().(2)Callable的任务执行后可返回值，而Runnable的任务是不能返回值得(3)call方法可以抛出异常，run方法不可以(4)运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。 怎么防止前端重复提交？ 提交按钮后屏蔽提交按钮(前端js控制) 前端生产唯一id，后端通过唯一索引（简单粗暴，我喜欢） 利用Session防止表单重复提交 推荐 方法1+方案2 组合套餐万无一失 SpringAOP的原理spring实现AOP的思路很简单， 通过预编译方式和运行期动态代理方式实现程序功能的统一维护的一种技术 主要功能：日志记录、性能统计、安全控制、事务处理、异常处理等等 AOP实现方式 预编译：AspectJ 运行期动态代理（JDK动态代理、CGLib动态代理）：SpringAOP、JbossAOP AOP几个相关概念 面向切面的核心思想就是，让核心的业务逻辑代码，不需要去管理一些通用的逻辑，比如说事务，安全等这方面的共同逻辑,解耦业务逻辑和通用逻辑 建议把 理论+实际应用方式 告诉面试官，虽然你可能没开发过但你一定要把核心概念思想表达出来 批量往mysql导入1000万数据有什么方法？减少IO次数 ​ SQL写法优化 ​ 合理设置批量大小 ​ 尽量顺序插入 一条SQL语句插入多条数据 在事务中进行插入处理，切记不要1条数据提交一下，肯定要分批处理 数据有序插入，是为了减少索引的维护压力 批量插入SQL例子，Ibatis的小demo &lt;!-- 批量插入流量模块 --&gt; &lt;insert id=&quot;XXX_表-BATCH-INSERT&quot; parameterClass=&quot;java.util.List&quot;&gt; INSERT INTO XXX_表(gmt_create,gmt_modified,字段A,字段B,字段C) VALUES &lt;iterate conjunction=&quot;,&quot;&gt; &lt;![CDATA[ (NOW(),NOW(),#vals[].字段A#,#vals[].字段B#,#vals[].字段C#) ]]&gt; &lt;/iterate&gt; &lt;/insert&gt; 事务 START TRANSACTION; INSERT INTO XXX_表(gmt_create,gmt_modified,字段A,字段B,字段C) VALUES (NOW(),NOW(),#vals[].字段A#,#字段B[].字段C#) ... COMMIT; 总结 ​ 合并数据+事务+有序数据的优化插入方式 ​ 注意SQL批量插入的大小必须合理 ​ 事务执行时间不要太长了 ​ 实际开发时需要合理设置MYSQL相应配置参数，增加缓存或减少不必要日志磁盘读写 项目中日志框架，日志具体怎么配置 Loggers 记录器 （日志文件基本配置） | Appenders 附加器 （日志文件去哪里） ​ | ​ Layouts 布局器（日志文件输出具体格式） 三大组件成就了log4j 这里可简单理解为日志类别，日志要输出的地方和日志以何种形式输出 如果是log4j.xml 核心标签 log4j root ​ logger ​ level 日志级别 appender 日志文件输出地​ layout 输出具体格式 appender 一般一个日志文件就对应一个，依赖layout file、append、 encoding logger 一般代码模块类路径一一对应，如 com.程序汪公司.系统.模块名 ，依赖level appenderlevel 日志级别 root 默认日志，依赖level appender ———-log4j面试场景回顾———- 面试官：程序汪日志级别怎么配置 汪：Loggers 组件 …… 面试官：程序汪日志输出位置怎么配置，日志文件是按天生成的还是什么规则 汪：Appenders 组件 ……DailyRollingFileAppender …… 面试官：程序汪日志的输出格式怎么配置 汪：Layouts 组件 ……PatternLayout …… 具体聊下配置信息吧 1、配置根Logger：log4j.rootLogger = [ level ] , appenderName1附加器, appenderName2附加器, … Loggers组件在此系统中被分为五个级别：DEBUG、INFO、WARN、ERROR和FATAL。这五个级别是有顺序的，DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL 企业项目生产环境一般都是设置INFO 级别 Appenders 附加器 （日志文件去哪里） 2、配置日志信息输出目的地（appender）： log4j.appender.appenderName = className appenderName：自定义appderName，在log4j.rootLogger设置中使用； className：可设值如下： (1)org.apache.log4j.ConsoleAppender（控制台） (2)org.apache.log4j.FileAppender（文件） (3)org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件） (4)org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件） #按DatePattern输出到文件 log4j.appender.logDailyFile = org.apache.log4j.DailyRollingFileAppender log4j.appender.logDailyFile.layout = org.apache.log4j.PatternLayout log4j.appender.logDailyFile.layout.ConversionPattern = [%-5p][%-22d{yyyy/MM/dd HH:mm:ssS}][%l]%n%m%n log4j.appender.logDailyFile.Threshold = DEBUG log4j.appender.logDailyFile.ImmediateFlush = TRUE log4j.appender.logDailyFile.Append = TRUE log4j.appender.logDailyFile.File = ../Struts2/WebRoot/log/DailyFile/log4j_Struts log4j.appender.logDailyFile.DatePattern = &#39;.&#39;yyyy-MM-dd-HH-mm&#39;.log&#39; log4j.appender.logDailyFile.Encoding = UTF-83、配置日志信息的输出格式（Layout）： log4j.appender.appenderName.layout=className className：可设值如下： (org.apache.log4j.PatternLayout（可以灵活地指定布局模式，企业项目中一般都是自己定义格式） PatternLayout选项： ConversionPattern=%m%n：设定以怎样的格式显示消息。 配置文件 log4j.properties log4j.xml （我公司就是配置这个模式） log4j.xml格式 我把关键词提取出来 log4j appender 输出配置 layout 布局","categories":[{"name":"面试","slug":"面试","permalink":"mumudadi.top/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"mumudadi.top/tags/%E9%9D%A2%E8%AF%95/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"mumudadi.top/categories/%E9%9D%A2%E8%AF%95/"}]},{"title":"if-else優化","slug":"if-else","date":"2020-01-07T09:16:01.000Z","updated":"2020-02-04T14:40:33.591Z","comments":true,"path":"2020/01/07/if-else/","link":"","permalink":"mumudadi.top/2020/01/07/if-else/","excerpt":"","text":"​ 在开发中我们经常会碰到有些场景，需要根据某个字段的不同含义，去执行不同的逻辑操作，一般我们会倾向于使用if/else或者switch/case的方式，但当字段的含义不断增加，或者各种含义情况都需要执行非常多逻辑的时候，使用if/else/switch会使代码不易维护，且可读性差。那么，使用枚举，将是一种非常好的改善方式。 ​ 举例：当不同角色去审批员工请假单时，执行的逻辑是不一样的，比如直属小组长需要确认员工的工作进度是否正常，工作交接是否正常，而团队负责人要确认总项目进度是否有影响等等。如果使用if/else的方式，我们的代码会是如下这样： public void judge(Long applyId, String role){ if (role.equals(&quot;leader&quot;)) { //leader doing } else if (role.equals(&quot;service owner&quot;)) { //service owner doing } else if (role.equals(&quot;project manager&quot;)) { //project manager doing } else if (role.equals(&quot;supervisor&quot;)) { //supervisor doing }​ 后续如果再增加人物角色，会不断增多if/else，有代码洁癖的会很难受。。一旦角色数量达到几十的时候，看代码估计要疯。。非常不利于扩展和维护。 接下来我们使用java枚举的方式改造一下。首先定义一个公用接口： public interface RoleService { //审批操作，后续增加其他操作只需要再新建方法 void approve(); } ​ 接下来我们定义一个不同角色执行不同逻辑的枚举类 RoleServiceEnum来实现接口，将不同角色的逻辑全部交由这个枚举类来做： public enum RoleServiceEnum implements RoleService { ROLE_LEADER(){ @Override public void approve() { System.out.println(&quot;leader doing sth&quot;); } }, ROLE_SERVICE_OWNER(){ @Override public void approve() { System.out.println(&quot;so doing sth&quot;); } }, ROLE_PROJECT_MANAGER(){ @Override public void approve() { System.out.println(&quot;pm doing sth&quot;); } }, ROLE_SUPERVISOR(){ @Override public void approve() { System.out.println(&quot;supervisor doing sth&quot;); } }; 接下来我们再调用这个枚举类，执行不同角色审批请假单的逻辑，一行代码就行了： public void judge(String role){ RoleServiceEnum.valueOf(role).approve(); }使用工厂模式：​ 不同分支做不同的事情，很明显就提供了使用工厂模式的契机，我们只需要将不同情况单独定义好，然后去工厂类里面聚合即可。 ​ 首先，针对不同的角色，单独定义其业务类: public class RootAdminRole implements Roleoperation { private String roleName; public RootAdminRole(String roleName) { this.roleName = roleName; } @Override public String op() { return roleName+&quot;系统管理员操作权限&quot;; } }public class OrderAdminRole implements Roleoperation { private String roleName; public OrderAdminRole(String roleName) { this.roleName = roleName; } @Override public String op() { return roleName+&quot;订单管理员操作权限&quot;; } }public class NormalRole implements Roleoperation { private String roleName; public NormalRole(String roleName) { this.roleName = roleName; } @Override public String op() { return roleName+&quot;普通用户操作权限&quot;; } }接下来再写一个工厂类RoleFactory对上面不同角色进行聚合： public class RoleFactory { static Map&lt;String,Roleoperation&gt; roleoperationMap = new HashMap&lt;&gt;(); static { roleoperationMap.put(&quot;ROOT_ADMIN&quot;,new RootAdminRole(&quot;ROOT_ADMIN&quot;)); roleoperationMap.put(&quot;ORDER_ADMIN&quot;,new RootAdminRole(&quot;ORDER_ADMIN&quot;)); roleoperationMap.put(&quot;NORMAL&quot;,new RootAdminRole(&quot;NORMAL&quot;)); } public static Roleoperation getOp(String roleName){ return roleoperationMap.get(roleName); } 接下来借助上面这个工厂，业务代码调用也只需要一行代码，if/else同样被消除了 RoleFactory.getOp(&quot;ROOT_ADMIN&quot;).op()这样的话以后想扩展条件也很容易，只需要增加新代码，而不需要动以前的业务代码，非常符合“开闭原则”。","categories":[{"name":"面试","slug":"面试","permalink":"mumudadi.top/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"mumudadi.top/tags/%E9%9D%A2%E8%AF%95/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"mumudadi.top/categories/%E9%9D%A2%E8%AF%95/"}]},{"title":"spring boot 接口響應json數據格式封裝","slug":"AjaxResult","date":"2020-01-05T09:16:01.000Z","updated":"2020-02-04T14:40:56.186Z","comments":true,"path":"2020/01/05/AjaxResult/","link":"","permalink":"mumudadi.top/2020/01/05/AjaxResult/","excerpt":"","text":"現在很多項目都是用前後端分離的形式來寫接口，對於數據返回的規則也是必不可少的。 在實際開發當中我們時常要把實體對象以json數據的格式響應，這就要使用到一些轉換json工具類，在controller層也常用@ResponseBody注解實現。以Ajax請求響應json數據爲例進行封裝：需要有相應 狀態碼code、消息msg、數據data public class AjaxResult extends HashMap&lt;String, Object&gt; { private static final long serialVersionUID = 1L; public static final String CODE_TAG = &quot;code&quot;; public static final String MSG_TAG = &quot;msg&quot;; public static final String DATA_TAG = &quot;data&quot;; /** * 状态类型 */ public enum Type { /** 成功 */ SUCCESS(0), /** 警告 */ WARN(301), /** 错误 */ ERROR(500); private final int value; Type(int value) { this.value = value; } public int value() { return this.value; } } /** * 初始化一个新创建的 AjaxResult 对象，使其表示一个空消息。 */ public AjaxResult() { } /** * 初始化一个新创建的 AjaxResult 对象 * * @param type 状态类型 * @param msg 返回内容 */ public AjaxResult(Type type, String msg) { super.put(CODE_TAG, type.value); super.put(MSG_TAG, msg); } /** * 初始化一个新创建的 AjaxResult 对象 * * @param type 状态类型 * @param msg 返回内容 * @param data 数据对象 */ public AjaxResult(Type type, String msg, Object data) { super.put(CODE_TAG, type.value); super.put(MSG_TAG, msg); if (StringUtils.isNotNull(data)) { super.put(DATA_TAG, data); } } /** * 返回成功消息 * * @return 成功消息 */ public static AjaxResult success() { return AjaxResult.success(&quot;操作成功&quot;); } /** * 返回成功数据 * * @return 成功消息 */ public static AjaxResult success(Object data) { return AjaxResult.success(&quot;操作成功&quot;, data); } /** * 返回成功消息 * * @param msg 返回内容 * @return 成功消息 */ public static AjaxResult success(String msg) { return AjaxResult.success(msg, null); } /** * 返回成功消息 * * @param msg 返回内容 * @param data 数据对象 * @return 成功消息 */ public static AjaxResult success(String msg, Object data) { return new AjaxResult(Type.SUCCESS, msg, data); } /** * 返回警告消息 * * @param msg 返回内容 * @return 警告消息 */ public static AjaxResult warn(String msg) { return AjaxResult.warn(msg, null); } /** * 返回警告消息 * * @param msg 返回内容 * @param data 数据对象 * @return 警告消息 */ public static AjaxResult warn(String msg, Object data) { return new AjaxResult(Type.WARN, msg, data); } /** * 返回错误消息 * * @return */ public static AjaxResult error() { return AjaxResult.error(&quot;操作失败&quot;); } /** * 返回错误消息 * * @param msg 返回内容 * @return 警告消息 */ public static AjaxResult error(String msg) { return AjaxResult.error(msg, null); } /** * 返回错误消息 * * @param msg 返回内容 * @param data 数据对象 * @return 警告消息 */ public static AjaxResult error(String msg, Object data) { return new AjaxResult(Type.ERROR, msg, data); } } controller層調用 注意加上注解@ResponseBody @PostMapping(&quot;/login&quot;) @ResponseBody public AjaxResult ajaxLogin(String username, String password, Boolean rememberMe) { UsernamePasswordToken token = new UsernamePasswordToken(username, password, rememberMe); Subject subject = SecurityUtils.getSubject(); try { subject.login(token); return AjaxResult.success(); } catch (AuthenticationException e) { String msg = &quot;用户或密码错误&quot;; if (StringUtils.isNotEmpty(e.getMessage())) { msg = e.getMessage(); } return AjaxResult.error(msg); } }響應json {&quot;msg&quot;:&quot;操作成功&quot;,&quot;code&quot;:0}針對一些特殊組件需要的數據格式可自定義數據對象，例如表格分頁數據，需要有total縂記錄數 public class TableDataInfo implements Serializable { private static final long serialVersionUID = 1L; /** 总记录数 */ private long total; /** 列表数据 */ private List&lt;?&gt; rows; /** 消息状态码 */ private int code; /** 消息内容 */ private int msg; /** * 表格数据对象 */ public TableDataInfo() { } /** * 分页 * * @param list 列表数据 * @param total 总记录数 */ public TableDataInfo(List&lt;?&gt; list, int total) { this.rows = list; this.total = total; } 。。。。。此處省略get,set方法","categories":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"mumudadi.top/tags/spring-boot/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"阿帕奇poi導入導出Excel","slug":"Excel","date":"2020-01-05T09:16:01.000Z","updated":"2020-02-04T14:40:21.912Z","comments":true,"path":"2020/01/05/Excel/","link":"","permalink":"mumudadi.top/2020/01/05/Excel/","excerpt":"","text":"導入依賴：&lt;!-- excel工具 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;${poi.version}&lt;/version&gt; &lt;/dependency&gt;在实体变量上添加@Excel注解@Excel(name = &quot;用户序号&quot;, prompt = &quot;用户编号&quot;) private Long userId; @Excel(name = &quot;用户名称&quot;) private String userName; @Excel(name = &quot;用户性别&quot;, readConverterExp = &quot;0=男,1=女,2=未知&quot;) private String sex; @Excel(name = &quot;最后登陆时间&quot;, width = 30, dateFormat = &quot;yyyy-MM-dd HH:mm:ss&quot;) private Date loginDate;撰寫工具類：public class ExcelUtil&lt;T&gt; { 。。。。。省略N行代碼 /** * 对excel表单指定表格索引名转换成list * * @param sheetName 表格索引名 * @param is 输入流 * @return 转换后集合 */ public List&lt;T&gt; importExcel(String sheetName, InputStream is) throws Exception { this.type = Type.IMPORT; this.wb = WorkbookFactory.create(is); List&lt;T&gt; list = new ArrayList&lt;T&gt;(); Sheet sheet = null; if (StringUtils.isNotEmpty(sheetName)) { // 如果指定sheet名,则取指定sheet中的内容. sheet = wb.getSheet(sheetName); } else { // 如果传入的sheet名不存在则默认指向第1个sheet. sheet = wb.getSheetAt(0); } if (sheet == null) { throw new IOException(&quot;文件sheet不存在&quot;); } int rows = sheet.getPhysicalNumberOfRows(); if (rows &gt; 0) { // 定义一个map用于存放excel列的序号和field. Map&lt;String, Integer&gt; cellMap = new HashMap&lt;String, Integer&gt;(); // 获取表头 Row heard = sheet.getRow(0); for (int i = 0; i &lt; heard.getPhysicalNumberOfCells(); i++) { Cell cell = heard.getCell(i); if (StringUtils.isNotNull(cell != null)) { String value = this.getCellValue(heard, i).toString(); cellMap.put(value, i); } else { cellMap.put(null, i); } } // 有数据时才处理 得到类的所有field. Field[] allFields = clazz.getDeclaredFields(); // 定义一个map用于存放列的序号和field. Map&lt;Integer, Field&gt; fieldsMap = new HashMap&lt;Integer, Field&gt;(); for (int col = 0; col &lt; allFields.length; col++) { Field field = allFields[col]; Excel attr = field.getAnnotation(Excel.class); if (attr != null &amp;&amp; (attr.type() == Type.ALL || attr.type() == type)) { // 设置类的私有字段属性可访问. field.setAccessible(true); Integer column = cellMap.get(attr.name()); fieldsMap.put(column, field); } } for (int i = 1; i &lt; rows; i++) { // 从第2行开始取数据,默认第一行是表头. Row row = sheet.getRow(i); T entity = null; for (Map.Entry&lt;Integer, Field&gt; entry : fieldsMap.entrySet()) { Object val = this.getCellValue(row, entry.getKey()); // 如果不存在实例则新建. entity = (entity == null ? clazz.newInstance() : entity); // 从map中得到对应列的field. Field field = fieldsMap.get(entry.getKey()); // 取得类型,并根据对象类型设置值. Class&lt;?&gt; fieldType = field.getType(); if (String.class == fieldType) { String s = Convert.toStr(val); if (StringUtils.endsWith(s, &quot;.0&quot;)) { val = StringUtils.substringBefore(s, &quot;.0&quot;); } else { String dateFormat = field.getAnnotation(Excel.class).dateFormat(); if (StringUtils.isNotEmpty(dateFormat)) { val = DateUtils.parseDateToStr(dateFormat, (Date) val); } else { val = Convert.toStr(val); } } } else if ((Integer.TYPE == fieldType) || (Integer.class == fieldType)) { val = Convert.toInt(val); } else if ((Long.TYPE == fieldType) || (Long.class == fieldType)) { val = Convert.toLong(val); } else if ((Double.TYPE == fieldType) || (Double.class == fieldType)) { val = Convert.toDouble(val); } else if ((Float.TYPE == fieldType) || (Float.class == fieldType)) { val = Convert.toFloat(val); } else if (BigDecimal.class == fieldType) { val = Convert.toBigDecimal(val); } else if (Date.class == fieldType) { if (val instanceof String) { val = DateUtils.parseDate(val); } else if (val instanceof Double) { val = DateUtil.getJavaDate((Double) val); } } if (StringUtils.isNotNull(fieldType)) { Excel attr = field.getAnnotation(Excel.class); String propertyName = field.getName(); if (StringUtils.isNotEmpty(attr.targetAttr())) { propertyName = field.getName() + &quot;.&quot; + attr.targetAttr(); } else if (StringUtils.isNotEmpty(attr.readConverterExp())) { val = reverseByExp(String.valueOf(val), attr.readConverterExp()); } ReflectUtils.invokeSetter(entity, propertyName, val); } } list.add(entity); } } return list; } 。。。。。。。。。食用： ExcelUtil&lt;User&gt; util = new ExcelUtil&lt;User&gt;(User.class); List&lt;User&gt; userList = util.importExcel(file.getInputStream()); String message = userService.importUser(userList, updateSupport);List&lt;User&gt; list = userService.selectUserList(user); ExcelUtil&lt;User&gt; util = new ExcelUtil&lt;User&gt;(User.class); return util.exportExcel(list, &quot;用户数据&quot;);","categories":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Excel","slug":"Excel","permalink":"mumudadi.top/tags/Excel/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"系統日志logback使用方式","slug":"Log","date":"2020-01-02T14:16:01.000Z","updated":"2020-02-04T14:40:04.094Z","comments":true,"path":"2020/01/02/Log/","link":"","permalink":"mumudadi.top/2020/01/02/Log/","excerpt":"","text":"​ 在实际开发中，对于某些关键业务，我们通常需要记录该操作的内容，一个操作调一次记录方法，每次还得去收集参数等等，会造成大量代码重复。 我们希望代码中只有业务相关的操作，在项目中使用注解来完成此项功能。 在需要被记录日志的controller方法上添加@Log注解，使用方法如下： @Log(title = &quot;用户管理&quot;, businessType = BusinessType.INSERT) 关于自定义操作功能使用流程 在BusinessType中新增业务操作类型 public enum BusinessType { /** * 其它 */ OTHER, /** * 新增 */ INSERT, /** * 修改 */ UPDATE, /** * 删除 */ DELETE, /** * 授权 */ GRANT, /** * 导出 */ EXPORT, /** * 导入 */ IMPORT, /** * 强退 */ FORCE, /** * 生成代码 */ GENCODE, /** * 清空数据 */ CLEAN, } application.yml# 日志配置 logging: level: com.ruoyi: debug org.springframework: warn","categories":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Log","slug":"Log","permalink":"mumudadi.top/tags/Log/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"動態數據源實現","slug":"DynamicDataSource","date":"2019-10-13T14:16:01.000Z","updated":"2020-02-04T14:39:43.340Z","comments":true,"path":"2019/10/13/DynamicDataSource/","link":"","permalink":"mumudadi.top/2019/10/13/DynamicDataSource/","excerpt":"","text":"​ 在实际开发中，经常可能遇到在一个应用中可能需要访问多个数据库的情况 在需要切换数据源Service或Mapper方法上添加@DataSource注解@DataSource(value = DataSourceType.MASTER)，其中value用来表示数据源名称 自定義注解*/ @Target({ ElementType.METHOD, ElementType.TYPE }) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited public @interface DataSource { /** * 切换数据源名称 */ public DataSourceType value() default DataSourceType.MASTER; }在application-druid.yml配置从库数据源# 从库数据源 slave: # 从数据源开关/默认关闭 enabled: true url: jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2B8 username: root password: password在DataSourceType类添加数据源枚举/** * 从库 */ SLAVE數據源切換處理public class DynamicDataSourceContextHolder { public static final Logger log = LoggerFactory.getLogger(DynamicDataSourceContextHolder.class); /** * 使用ThreadLocal维护变量，ThreadLocal为每个使用该变量的线程提供独立的变量副本， * 所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。 */ private static final ThreadLocal&lt;String&gt; CONTEXT_HOLDER = new ThreadLocal&lt;&gt;(); /** * 设置数据源的变量 */ public static void setDataSourceType(String dsType) { log.info(&quot;切换到{}数据源&quot;, dsType); CONTEXT_HOLDER.set(dsType); } /** * 获得数据源的变量 */ public static String getDataSourceType() { return CONTEXT_HOLDER.get(); } /** * 清空数据源变量 */ public static void clearDataSourceType() { CONTEXT_HOLDER.remove(); } }多數據源處理@Aspect @Order(1) @Component public class DataSourceAspect { protected Logger logger = LoggerFactory.getLogger(getClass()); @Pointcut(&quot;@annotation(com.ruoyi.framework.aspectj.lang.annotation.DataSource)&quot; + &quot;|| @within(com.ruoyi.framework.aspectj.lang.annotation.DataSource)&quot;) public void dsPointCut() { } @Around(&quot;dsPointCut()&quot;) public Object around(ProceedingJoinPoint point) throws Throwable { DataSource dataSource = getDataSource(point); if (StringUtils.isNotNull(dataSource)) { DynamicDataSourceContextHolder.setDataSourceType(dataSource.value().name()); } try { return point.proceed(); } finally { // 销毁数据源 在执行方法之后 DynamicDataSourceContextHolder.clearDataSourceType(); } } /** * 获取需要切换的数据源 */ public DataSource getDataSource(ProceedingJoinPoint point) { MethodSignature signature = (MethodSignature) point.getSignature(); Class&lt;? extends Object&gt; targetClass = point.getTarget().getClass(); DataSource targetDataSource = targetClass.getAnnotation(DataSource.class); if (StringUtils.isNotNull(targetDataSource)) { return targetDataSource; } else { Method method = signature.getMethod(); DataSource dataSource = method.getAnnotation(DataSource.class); return dataSource; } } } druid配置多數據源@Configuration public class DruidConfig { @Bean @ConfigurationProperties(&quot;spring.datasource.druid.master&quot;) public DataSource masterDataSource(DruidProperties druidProperties) { DruidDataSource dataSource = DruidDataSourceBuilder.create().build(); return druidProperties.dataSource(dataSource); } @Bean @ConfigurationProperties(&quot;spring.datasource.druid.slave&quot;) @ConditionalOnProperty(prefix = &quot;spring.datasource.druid.slave&quot;, name = &quot;enabled&quot;, havingValue = &quot;true&quot;) public DataSource slaveDataSource(DruidProperties druidProperties) { DruidDataSource dataSource = DruidDataSourceBuilder.create().build(); return druidProperties.dataSource(dataSource); } @Bean(name = &quot;dynamicDataSource&quot;) @Primary public DynamicDataSource dataSource(DataSource masterDataSource) { Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;(); targetDataSources.put(DataSourceType.MASTER.name(), masterDataSource); //在DruidConfig类dataSource方法添加数据源 setDataSource(targetDataSources, DataSourceType.SLAVE.name(), &quot;slaveDataSource&quot;); return new DynamicDataSource(masterDataSource, targetDataSources); } /** * 设置数据源 * * @param targetDataSources 备选数据源集合 * @param sourceName 数据源名称 * @param beanName bean名称 */ public void setDataSource(Map&lt;Object, Object&gt; targetDataSources, String sourceName, String beanName) { try { DataSource dataSource = SpringUtils.getBean(beanName); targetDataSources.put(sourceName, dataSource); } catch (Exception e) { } } } 使用 @DataSource(value = DataSourceType.SLAVE) public List&lt;SysUser&gt; selectUserList(SysUser user) { return userMapper.selectUserList(user); }对于特殊情况可以通过DynamicDataSourceContextHolder手动实现数据源切换 public List&lt;SysUser&gt; selectUserList(SysUser user) { DynamicDataSourceContextHolder.setDataSourceType(DataSourceType.SLAVE.name()); List&lt;SysUser&gt; userList = userMapper.selectUserList(user); DynamicDataSourceContextHolder.clearDataSourceType(); return userList; }","categories":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Dynamic","slug":"Dynamic","permalink":"mumudadi.top/tags/Dynamic/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"通用上傳下載","slug":"Upload-Download","date":"2019-10-11T14:16:01.000Z","updated":"2020-02-04T14:39:30.763Z","comments":true,"path":"2019/10/11/Upload-Download/","link":"","permalink":"mumudadi.top/2019/10/11/Upload-Download/","excerpt":"","text":"引入依賴&lt;!--文件上传工具类 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;${commons.fileupload.version}&lt;/version&gt; &lt;/dependency&gt;通用上傳：@PostMapping(&quot;/common/upload&quot;) @ResponseBody public AjaxResult uploadFile(MultipartFile file) throws Exception { try { // 上传文件路径 String filePath = RuoYiConfig.getUploadPath(); // 上传并返回新文件名称 String fileName = FileUploadUtils.upload(filePath, file); String url = serverConfig.getUrl() + fileName; AjaxResult ajax = AjaxResult.success(); ajax.put(&quot;fileName&quot;, fileName); ajax.put(&quot;url&quot;, url); return ajax; } catch (Exception e) { return AjaxResult.error(e.getMessage()); } } /** * 文件上传 * * @param baseDir 相对应用的基目录 * @param file 上传的文件 * @param extension 上传文件类型 * @return 返回上传成功的文件名 * @throws FileSizeLimitExceededException 如果超出最大大小 * @throws FileNameLengthLimitExceededException 文件名太长 * @throws IOException 比如读写文件出错时 * @throws InvalidExtensionException 文件校验异常 */ public static final String upload(String baseDir, MultipartFile file, String[] allowedExtension) throws FileSizeLimitExceededException, IOException, FileNameLengthLimitExceededException, InvalidExtensionException { int fileNamelength = file.getOriginalFilename().length(); if (fileNamelength &gt; FileUploadUtils.DEFAULT_FILE_NAME_LENGTH) { throw new FileNameLengthLimitExceededException(FileUploadUtils.DEFAULT_FILE_NAME_LENGTH); } assertAllowed(file, allowedExtension); String fileName = extractFilename(file); File desc = getAbsoluteFile(baseDir, fileName); //**核心操作**// file.transferTo(desc); String pathFileName = getPathFileName(baseDir, fileName); return pathFileName; }通用下載： @GetMapping(&quot;/common/download/resource&quot;) public void resourceDownload(String resource, HttpServletRequest request, HttpServletResponse response) throws Exception { // 本地资源路径 String localPath = RuoYiConfig.getProfile(); // 数据库资源地址 String downloadPath = localPath + StringUtils.substringAfter(resource, Constants.RESOURCE_PREFIX); // 下载名称 String downloadName = StringUtils.substringAfterLast(downloadPath, &quot;/&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;multipart/form-data&quot;); response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;fileName=&quot; + FileUtils.setFileDownloadHeader(request, downloadName)); FileUtils.writeBytes(downloadPath, response.getOutputStream()); } * 输出指定文件的byte数组 * * @param filePath 文件路径 * @param os 输出流 * @return */ public static void writeBytes(String filePath, OutputStream os) throws IOException { FileInputStream fis = null; try { File file = new File(filePath); if (!file.exists()) { throw new FileNotFoundException(filePath); } fis = new FileInputStream(file); byte[] b = new byte[1024]; int length; while ((length = fis.read(b)) &gt; 0) { os.write(b, 0, length); } } catch (IOException e) { throw e; } finally { if (os != null) { try { os.close(); } catch (IOException e1) { e1.printStackTrace(); } } if (fis != null) { try { fis.close(); } catch (IOException e1) { e1.printStackTrace(); } } } }","categories":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"upload","slug":"upload","permalink":"mumudadi.top/tags/upload/"},{"name":"download","slug":"download","permalink":"mumudadi.top/tags/download/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"數據權限控制Permission","slug":"Permission","date":"2019-10-10T14:16:01.000Z","updated":"2020-02-04T14:39:16.975Z","comments":true,"path":"2019/10/10/Permission/","link":"","permalink":"mumudadi.top/2019/10/10/Permission/","excerpt":"","text":"​ 在实际开发中，需要设置用户只能查看哪些部门的数据，这种情况一般称为数据权限。 例如对于销售，财务的数据，它们是非常敏感的，因此要求对数据权限进行控制， 对于基于集团性的应用系统而言，就更多需要控制好各自公司的数据了。如设置只能看本公司、或者本部门的数据，对于特殊的领导，可能需要跨部门的数据， 因此程序不能硬编码那个领导该访问哪些数据，需要进行后台的权限和数据权限的控制。 創建自定義注解/** * 数据权限过滤注解 * @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface DataScope { /** * 部门表的别名 */ public String deptAlias() default &quot;&quot;; /** * 用户表的别名 */ public String userAlias() default &quot;&quot;; }邏輯實現類@Aspect @Component public class DataScopeAspect { /** * 全部数据权限 */ public static final String DATA_SCOPE_ALL = &quot;1&quot;; 。。。。。。 /** * 数据范围过滤 * * @param joinPoint 切点 * @param user 用户 * @param alias 别名 */ public static void dataScopeFilter(JoinPoint joinPoint, User user, String deptAlias, String userAlias) { StringBuilder sqlString = new StringBuilder(); for (Role role : user.getRoles()) { String dataScope = role.getDataScope(); if (DATA_SCOPE_ALL.equals(dataScope)) { sqlString = new StringBuilder(); break; } else if (DATA_SCOPE_CUSTOM.equals(dataScope)) { sqlString.append(StringUtils.format( &quot; OR {}.dept_id IN ( SELECT dept_id FROM sys_role_dept WHERE role_id = {} ) &quot;, deptAlias, role.getRoleId())); } else if (DATA_SCOPE_DEPT.equals(dataScope)) { sqlString.append(StringUtils.format(&quot; OR {}.dept_id = {} &quot;, deptAlias, user.getDeptId())); } else if (DATA_SCOPE_DEPT_AND_CHILD.equals(dataScope)) { sqlString.append(StringUtils.format( &quot; OR {}.dept_id IN ( SELECT dept_id FROM sys_dept WHERE dept_id = {} or find_in_set( {} , ancestors ) )&quot;, deptAlias, user.getDeptId(), user.getDeptId())); } else if (DATA_SCOPE_SELF.equals(dataScope)) { if (StringUtils.isNotBlank(userAlias)) { sqlString.append(StringUtils.format(&quot; OR {}.user_id = {} &quot;, userAlias, user.getUserId())); } else { // 数据权限为仅本人且没有userAlias别名不查询任何数据 sqlString.append(&quot; OR 1=0 &quot;); } } } if (StringUtils.isNotBlank(sqlString.toString())) { BaseEntity baseEntity = (BaseEntity) joinPoint.getArgs()[0]; baseEntity.getParams().put(DATA_SCOPE, &quot; AND (&quot; + sqlString.substring(4) + &quot;)&quot;); } } 。。。。。。。。。。。。使用場景】 @Override @DataScope(deptAlias = &quot;d&quot;, userAlias = &quot;u&quot;) public List&lt;User&gt; selectUserList(User user) { // 生成数据权限过滤条件 return userMapper.selectUserList(user); }sql變化select u.user_id, u.dept_id, u.login_name, u.user_name, u.email , u.phonenumber, u.password, u.sex, u.avatar, u.salt , u.status, u.del_flag, u.login_ip, u.login_date, u.create_by , u.create_time, u.remark, d.dept_name from sys_user u left join sys_dept d on u.dept_id = d.dept_id where u.del_flag = &#39;0&#39; ${params.dataScope}and u.dept_id in ( select dept_id from sys_role_dept where role_id = 2 )","categories":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Permission","slug":"Permission","permalink":"mumudadi.top/tags/Permission/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"項目異常處理Exception","slug":"Exception","date":"2019-10-02T09:16:01.000Z","updated":"2020-02-04T14:36:59.310Z","comments":true,"path":"2019/10/02/Exception/","link":"","permalink":"mumudadi.top/2019/10/02/Exception/","excerpt":"","text":"​ 通常一个web框架中，有大量需要处理的异常。比如业务异常，权限不足等等。前端通过弹出提示信息的方式告诉用户出了什么错误。 通常情况下我们用try…..catch…. 对异常进行捕捉处理，但是在实际项目中对业务模块进行异常捕捉，会造成代码重复和繁杂， 我们希望代码中只有业务相关的操作，所有的异常我们单独设立一个类来处理它。全局异常就是对框架所有异常进行统一管理。 我们在可能发生异常的方法里throw抛给控制器。然后由全局异常处理器对异常进行统一处理。 如此，我们的Controller中的方法就可以很简洁了。 定義基礎異常public class BaseException extends RuntimeException { private static final long serialVersionUID = 1L; /** * 所属模块 */ private String module; /** * 错误码 */ private String code; /** * 错误码对应的参数 */ private Object[] args; /** * 错误消息 */ private String defaultMessage; public BaseException(String module, String code, Object[] args, String defaultMessage) { this.module = module; this.code = code; this.args = args; this.defaultMessage = defaultMessage; } public BaseException(String module, String code, Object[] args) { this(module, code, args, null); } public BaseException(String module, String defaultMessage) { this(module, null, null, defaultMessage); } public BaseException(String code, Object[] args) { this(null, code, args, null); } public BaseException(String defaultMessage) { this(null, null, null, defaultMessage); } @Override public String getMessage() { String message = null; if (!StringUtils.isEmpty(code)) { message = MessageUtils.message(code, args); } if (message == null) { message = defaultMessage; } return message; } public String getModule() { return module; } public String getCode() { return code; } public Object[] getArgs() { return args; } public String getDefaultMessage() { return defaultMessage; } @Override public String toString() { return this.getClass() + &quot;{&quot; + &quot;module=&#39;&quot; + module + &#39;\\&#39;&#39; + &quot;, message=&#39;&quot; + getMessage() + &#39;\\&#39;&#39; + &#39;}&#39;; } } 業務異常public class BusinessException extends RuntimeException { private static final long serialVersionUID = 1L; protected final String message; public BusinessException(String message) { this.message = message; } public BusinessException(String message, Throwable e) { super(message, e); this.message = message; } @Override public String getMessage() { return message; } }@ControllerAdvice实现优雅地处理异常 @ControllerAdvice，是Spring3.2提供的新注解,它是一个Controller增强器,可对controller中被 @RequestMapping注解的方法加一些逻辑处理。最常用的就是异常处理 @RestControllerAdvice public class GlobalExceptionHandler { private static final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class); * 业务异常 如果请求为ajax返回json，普通请求跳转页面 */ @ExceptionHandler(BusinessException.class) public Object businessException(HttpServletRequest request, BusinessException e) { log.error(e.getMessage(), e); if (ServletUtils.isAjaxRequest(request)) { return AjaxResult.error(e.getMessage()); } else { ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(&quot;errorMessage&quot;, e.getMessage()); modelAndView.setViewName(&quot;error/business&quot;); return modelAndView; } }應用： /** * 校验用户是否允许操作 * * @param user 用户信息 */ public void checkUserAllowed(User user) { if (StringUtils.isNotNull(user.getUserId()) &amp;&amp; user.isAdmin()) { throw new BusinessException(&quot;不允许操作超级管理员用户&quot;); } }","categories":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Exception","slug":"Exception","permalink":"mumudadi.top/tags/Exception/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"数据库知识要点","slug":"database","date":"2019-10-02T09:16:01.000Z","updated":"2020-02-04T14:36:43.804Z","comments":true,"path":"2019/10/02/database/","link":"","permalink":"mumudadi.top/2019/10/02/database/","excerpt":"","text":"一、基本概念 主键、外键、超键、候选键超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。 候选键：是最小超键，即没有冗余元素的超键。 主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。 外键：在一个表中存在的另一个表的主键称此表的外键。 为什么用自增列作为主键 如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引、 如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引、 如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。 数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点） 如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页 如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。 触发器的作用？ 触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。 什么是存储过程？用什么来调用？ 存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。 调用： 1）可以用一个命令对象来调用存储过程。 2）可以供外部程序调用，比如：java程序。 5.存储过程的优缺点？ 优点： 1）存储过程是预编译过的，执行效率高。 2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。 3）安全性高，执行存储过程需要有一定权限的用户。 4）存储过程可以重复使用，可减少数据库开发人员的工作量。 缺点： 移植性差","categories":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"mumudadi.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"手工实现HashMap","slug":"HashMap","date":"2019-05-02T07:51:01.000Z","updated":"2020-02-04T14:34:48.842Z","comments":true,"path":"2019/05/02/HashMap/","link":"","permalink":"mumudadi.top/2019/05/02/HashMap/","excerpt":"","text":"HashMap底层实现采用了哈希表，这是一种非常重要的数据结构。 数据结构中由数组和链表来实现堆数据的存储，他们各有特点。 数组：暂用空间连续。寻找地址容易，查询速度快。但是，增加和删除效率非常低。 链表：占用空间不连续，寻找地址困难，查询速度慢。但是，增加和删除效率非常高。 存储数据过程 package simple; import java.util.Arrays; import java.util.HashMap; public class HashMapTest&lt;K,V&gt; { class Node&lt;K,V&gt; { int hash; K key; V value; Node next; } Node[] table; int size; public HashMapTest() { table = new Node[16]; //长度一般定义为2的整数幂 } public void put(K key,V value){ //定义新的节点对象 Node newNode = new Node(); newNode.hash = key.hashCode()&amp;table.length; newNode.key = key; newNode.value = value; Node temp = table[newNode.hash]; if(temp==null){ table[newNode.hash] = newNode; size++; }else { while (temp!=null){ if(temp.key.equals(key)){ temp.value = value; //覆盖重复值 break; } if (temp.next!=null){ temp = temp.next; }else { temp.next = newNode;//没找到相同key 添加到链表最后 size++; break; } } } } public V get(K key){ for(int i=0;i&lt;size;i++){ Node temp = table[i]; while(temp!=null){ if(key.equals(temp.key)){ return (V)temp.value; } temp = temp.next; } } return null; } @Override public String toString() { StringBuilder sb = new StringBuilder(); sb.append(&quot;{&quot;); for(int i=0;i&lt;size;i++){ Node temp = table[i]; while(temp!=null){ sb.append(temp.key).append(&quot;=&quot;).append(temp.value).append(&quot;,&quot;); temp = temp.next; } } sb.setCharAt(sb.length()-1,&#39;}&#39;); return sb.toString(); } public static void main(String[] args) { HashMapTest&lt;Integer,String&gt; hashMapTest = new HashMapTest(); for(int i=0;i&lt;10;i++){ hashMapTest.put(i,&quot;lin&quot;+i); } System.out.println(hashMapTest.get(0)); System.out.println(hashMapTest.toString()); System.out.println(hashMapTest.size); } }","categories":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"mumudadi.top/tags/HashMap/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"手动实现LinkedList","slug":"LinkedList","date":"2019-05-02T07:41:01.000Z","updated":"2020-02-04T14:34:30.857Z","comments":true,"path":"2019/05/02/LinkedList/","link":"","permalink":"mumudadi.top/2019/05/02/LinkedList/","excerpt":"","text":"LinkedList底层用双向链表实现的存储。特点：查询效率低，增删效率高，线程不安全。 双向链表也叫双链表，是链表的一种，它的每个数据节点中都有两个指针，分别指向前一个节点和后一个节点。所以，从双向链表中的任意一个节点开始，都可以很方便地找到所有节点。 package simple; public class LinkedListTest&lt;T&gt; { class Node { Node previous; Node next; T element; public Node(Node previous, Node next, T element) { this.previous = previous; this.next = next; this.element = element; } public Node(T element) { this.element = element; } } private Node first; private Node last; private int size; public void add(T obj){ Node node = new Node(obj); if(first==null){ first = node; last = node; }else { node.previous = last; node.next = null; last.next = node; last = node; } size++; } public void add(int index,T obj){ Node newNode = new Node(obj); Node temp = getNode(index); if(temp!=null){ Node up = temp.previous; newNode.previous = up; up.next = newNode; newNode.next = temp; temp.previous = newNode; } size++; } public T get(int index) { checkRange(index); Node temp = getNode(index); return temp!=null?temp.element:null; } public Node getNode(int index){ Node temp = null; if(index&lt;=(index&gt;&gt;1)){ temp = first; for(int i=0;i&lt;index;i++){ temp = temp.next; } }else { temp = last; for(int i=size-1;i&gt;index;i--){ temp = temp.previous; } } return temp; } public void remove(int index){ Node temp = getNode(index); if(temp!=null){ Node up = temp.previous; Node down = temp.next; if(up!=null){ up.next = down; }else { first = down; } if(down!=null){ down.previous = up; }else { last = up; } } size--; } private void checkRange(int index){ if(index&lt;0||index&gt;size-1){ throw new RuntimeException(&quot;索引不合法&quot;+index); } } public String toString() { StringBuilder sb = new StringBuilder(); sb.append(&quot;[&quot;); Node temp = first; while(temp!=null){ sb.append(temp.element).append(&quot;,&quot;); temp = temp.next; } sb.setCharAt(sb.length()-1,&#39;]&#39;); return sb.toString(); } public static void main(String[] args) { LinkedListTest linkedListTest= new LinkedListTest&lt;Object&gt;(); for(int i=0;i&lt;10;i++){ linkedListTest.add(&quot;aa&quot;+i); } //linkedListTest.remove(9); linkedListTest.add(7,&quot;hello&quot;); System.out.println( linkedListTest.toString()); } } 总结： 做增删操作时注意把相邻两个节点衔接上。","categories":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"LinkList","slug":"LinkList","permalink":"mumudadi.top/tags/LinkList/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"手动实现ArrayList","slug":"ArrayList","date":"2019-05-02T07:37:01.000Z","updated":"2020-02-04T14:34:18.340Z","comments":true,"path":"2019/05/02/ArrayList/","link":"","permalink":"mumudadi.top/2019/05/02/ArrayList/","excerpt":"","text":"ArrayList底层用数组实现的存储。特点：查询效率高，增删效率低，线程不安全。我们一般使用它。package simple; import java.util.Arrays; public class ArrayListTest&lt;T&gt; { private Object[] elementData; private int size; private static final int DEFAULT_CAPACITY = 10; public ArrayListTest() { elementData = new Object[DEFAULT_CAPACITY]; } public ArrayListTest(int capacity) { if(capacity&lt;0){ throw new RuntimeException(&quot;容量不能为负数&quot;); }else if(capacity==0){ elementData = new Object[DEFAULT_CAPACITY]; }else { elementData = new Object[capacity]; } } public void add (T obj){ if(size == elementData.length){ Object[] newArray = new Object[elementData.length+(elementData.length&gt;&gt;1)]; System.arraycopy(elementData,0,newArray,0,elementData.length); elementData = newArray; } elementData[size++] = obj; } public T get(int index) { checkRange(index); return (T) elementData[index]; } public void set(int index,T obj) { checkRange(index); elementData[index] = obj; } public void checkRange(int index){ if(index&lt;0||index&gt;size-1){ throw new RuntimeException(&quot;索引不合法&quot;+index); } } public void remove(T element){ for(int i=0;i&lt;size;i++){ if(element.equals(get(i))){ remove(i); } } } public void remove(int index) { int numMoved = elementData.length-index-1; if(numMoved&gt;0){ System.arraycopy(elementData,index+1,elementData,index,numMoved); } elementData[--size] = null; } public int size(){ return size; } public boolean isEmpty(){ return size==0?true:false; } @Override public String toString() { StringBuilder sb = new StringBuilder(); sb.append(&quot;[&quot;); for(int i=0;i&lt;size;i++){ sb.append(elementData[i]+&quot;,&quot;); } sb.setCharAt(sb.length()-1,&#39;]&#39;); return sb.toString(); } public static void main(String[] args) { ArrayListTest s1= new ArrayListTest(20); for(int i=0;i&lt;10;i++){ s1.add(&quot;lin&quot;+i); } System.out.println(s1.get(9)); s1.remove(5); System.out.println(s1); s1.remove(&quot;lin3&quot;); System.out.println(s1); } } 原理总结： 底层数组扩容旧数组拷贝到新数组 System.arraycopy(elementData,0,newArray,0,elementData.length); remove方法先调用equals方法查找到相同元素，找到删除元素的数组下标用数组拷贝方法拆分重新整合新的数组并返回。","categories":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"ArrayList","slug":"ArrayList","permalink":"mumudadi.top/tags/ArrayList/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"Java垃圾回收机制","slug":"Garbage-Collection","date":"2019-05-02T07:31:01.000Z","updated":"2020-02-04T14:33:47.044Z","comments":true,"path":"2019/05/02/Garbage-Collection/","link":"","permalink":"mumudadi.top/2019/05/02/Garbage-Collection/","excerpt":"","text":"通用的分代垃圾回收机制​ 分代垃圾回收机制，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。我们将对象分为三种状态：年轻代、年老代、持久代。JVM将堆内存划分为Eden、Survivor和Tenured/Old空间。 年轻代 所有新生成的对象首先都是放在Eden区。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象，对应的是Minor GC，每次Minor GC 会清理年轻代的内存，算法采用效率较高的复制算法，频繁的操作，但是会浪费内存空间。当“年轻代”区域存放满对象后，就将对象存放到年老代区域。 年老代 在年轻代中经历了N(默认15)次垃圾回收后仍然存活的对象，就会被放到年老代中。因此可以认为年老代中存放的都是一些生命周期较长的对象。年老代对象越来越多，我们就需要启动Major GC和Full GC(全量回收)，来一次大扫除，全面清理年轻代区域和年老代区域。 持久代 用于存放静态文件，如Java类、方法等。持久代堆垃圾回收没有显著影响。 Minor GC： 用于清理年轻代区域。Eden区满了就会触发一次Minor GC。清理无用对象，将有用对象复制到“Survivor1”、“Survivor2”区中(这两个区，大小空间也相同，同一时刻Surivor1和Surivor2只有一个在用，一个为空) Major GC： 用于清理年老代区域。 Full GC: 用于清理年轻代、年老代区域。成本较高，会对系统产生影响。 垃圾回收过程： 新创建的对象，绝大多数都会存储在Eden中 当Eden满了(达到一定比例)不能创建新对象，则触发垃圾回收(GC )，将无用对象清理掉，然后剩余对象赋值到某个Survivor中，如S1，同时清空Eden区 当Eden区再次满了，会将S1中的不能清空的对象存到另外一个Surivor中，如S2，同时将Eden区中的不能清空的对象，也复制到S2中，保证Eden和S1，均被清空。 重复多次(默认15次)Survivor中没有被清理的对象，则会复制到老年代Old(Tenured)区中 当Old区满了，则会出发一个完整地垃圾回收(FullGC)，之前新生代的垃圾回收称为(minorGC) JVM调优和Full GC在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节。有如下原因可能导致Full GC： 年老代(Tenureed)被写满 持久代(Perm)被写满 System.gc()被显式调用(程序建议GC启动，不是调用GC) 上一次GC之后Heap的各域分配策略动态变化","categories":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"理解","slug":"理解","permalink":"mumudadi.top/tags/%E7%90%86%E8%A7%A3/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"Java虚拟机内存分析理解","slug":"memory-analyze","date":"2019-05-02T07:22:01.000Z","updated":"2020-02-04T14:33:21.358Z","comments":true,"path":"2019/05/02/memory-analyze/","link":"","permalink":"mumudadi.top/2019/05/02/memory-analyze/","excerpt":"","text":"概述Java虚拟机的内存可以分为三个区域：栈stack、堆heap、方法区method area 栈的特点如下： 栈描述的是方法执行的内存模型，每个方法被调用都会创建一个栈帧(存储局部变量、操作数、方法出口等) JVM为每个线程创建一个栈，用于存放该线程执行方法的信息(实际参数、局部变量等) 栈属于线程私有，不能实现线程间的共享！ 栈的内存特性是“先进后出，后进先出” 栈是由系统自动分配，速度快！栈是一个连续的内存空间！ 堆的特点如下： 堆用于存储创建好的对象和数组(数组也是对象) JVM只有一个堆，被所有线程共享 堆是一个不连续的内存空间，分配灵活，速度慢！ 方法区(又叫静态区)特点如下： JVM只有一个方法区，被所有线程共享！ 方法区实际也是堆，只是用于存储类、常量相关的信息！ 用来存放程序中永远是不变或唯一的内容。(类信息【Class对象】、静态变量、字符串常量等) 内存分配图","categories":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"理解","slug":"理解","permalink":"mumudadi.top/tags/%E7%90%86%E8%A7%A3/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"理解面向对象","slug":"Objent-oriented-Understand","date":"2019-05-02T07:20:01.000Z","updated":"2020-02-04T14:32:57.360Z","comments":true,"path":"2019/05/02/Objent-oriented-Understand/","link":"","permalink":"mumudadi.top/2019/05/02/Objent-oriented-Understand/","excerpt":"","text":"概述面向过程和面向对象都是对软件分析、设计和开发的一种思想，它知道着人们以不同的方式去分析、设计和开发软件。 面向过程面向过程思想思考问题时，我们首先思考“怎么按步骤实现？”并将步骤对应成方法，一步一步，最终完成。 这个适合简单任务，不需要过多协作的情况下。比如，如何开车？ 点火 挂挡 踩油门 开车 面向过程适合简单、不需要协作的事务。 但是当我们思考比较复杂的问题，比如“如何造车？”，就会发现列出1234这样的步骤，是不可能的。那是因为，造车太复杂，需要很对协作才能完成。此时面向对象思想就应运而生了。 面向对象面向对象(Object)想想更契合人的思维模式。我们首先思考的是“怎么设计这个事务？” 比如思考造车，我们就会先思考“车怎么设计？”，而不是“怎么按步骤造车的问题”。 总结 都是解决问题的思维方式，都是代码组织的方式。 解决简单问题可以使用面向过程 解决复杂问题：宏观上使用面向对象把握，微观处理上仍然是面向过程。","categories":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"理解","slug":"理解","permalink":"mumudadi.top/tags/%E7%90%86%E8%A7%A3/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"造成内存泄漏的操作","slug":"memory-leak","date":"2019-05-02T07:16:01.000Z","updated":"2020-02-04T14:32:36.284Z","comments":true,"path":"2019/05/02/memory-leak/","link":"","permalink":"mumudadi.top/2019/05/02/memory-leak/","excerpt":"","text":"建议： 在实际开发中，经常会造成系统的崩溃。如下这些操作我们应该注意这些使用场景。 创建大量无用对象 比如，我们在需要大量拼接字符串时，使用了String而不是StringBuilder。 String str = &quot;&quot;; for (int i = 0; i&lt;10000; i++){ str += i; //相当于产生了10000个string对象 } 静态类集合的使用 想HashMap、Vector、List等的使用最容易出现内存泄漏，这些静态变量的生命周期和应用程序一致，所有对象Object也不能被释放。 各种连接对象(IO流对象、数据库连接对象、网络连接对象)未关闭 IO流对象、数据库连接对象、网络连接对象等连接对象属于物理连接，和硬盘或者网络连接，不使用时一定要关闭。 监听器的使用 释放对象时，没有删除相应的监听器。 要点： 程序员无权调用垃圾回收器。 程序员可以调用System.gc(),该方法知识通知 JVM，并不是运行垃圾回收器，尽量少用，会申请启动Full GC ，成本高，影响系统性能。 finalize方法，是Java提供给程序员用来释放对象或资源的方法，但是尽量少用。","categories":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"理解","slug":"理解","permalink":"mumudadi.top/tags/%E7%90%86%E8%A7%A3/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"吸引面试官要点","slug":"enjoy","date":"2019-01-02T07:16:01.000Z","updated":"2020-02-04T14:38:41.443Z","comments":true,"path":"2019/01/02/enjoy/","link":"","permalink":"mumudadi.top/2019/01/02/enjoy/","excerpt":"","text":"面试官喜欢什么样的人？ 秉性良好、谈吐正常的人 精心准备自我介绍（突出实践经验、而不是爱好！） 交谈大方，无小动作（别太紧张） 衣着干净整洁 懂得感恩。不说公司、老师、老板、同事的坏话 工作态度端正、认真工作的人 是否一切以公司事务为重 加班问题 大大方方谈薪水（接受薪水不是越低越好，适当的区间） 热爱本职工作、有合理职业规划 一定要明确自己的职业规划！与企业发展理念相一致，切勿说自己只是来过度！ 工作会不会给你带来快乐 至少规划3年的职业规划，注意合理（不放大，也不缩小） 热爱学习、喜欢提升自己的人 自己平时如何学习？有哪些学习习惯或者学习技巧？请推荐一本你最近阅读的专业书籍。 参加和本职工作，相关的培训（利用业余时间，周末和晚上） 最近对XXX新技术感兴趣，正在研究 技术牛，完全可以胜任工作 最后一点，用心对待，面试官也能感受到","categories":[{"name":"面试","slug":"面试","permalink":"mumudadi.top/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"mumudadi.top/tags/%E9%9D%A2%E8%AF%95/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"mumudadi.top/categories/%E9%9D%A2%E8%AF%95/"}]},{"title":"写好简历的六大要素","slug":"resume","date":"2019-01-02T07:16:01.000Z","updated":"2020-02-04T14:38:25.117Z","comments":true,"path":"2019/01/02/resume/","link":"","permalink":"mumudadi.top/2019/01/02/resume/","excerpt":"","text":"简历是求职的名片 简历必须：一字一字自己写，不能抄袭！ 要对自己写的内容负责，写之前先问自己是否真的熟悉掌握，了解自己哪一块知识点比较薄弱。准备简历的过程也是准备面试的过程。 基本情况介绍 姓名、性别、学历、专业、联系方式等 专业技能 有条理的罗列自己的专业技能 求职意向 准确的求职意向 工作经验和项目经验 详细的工作履历、项目经验 曾获奖励 罗列一些工作相关奖励、不相关引以为豪的奖励。 自我评价 突出和工作相关的自我特质和优点 项目经验这里需要重点准备，做过的什么类型的项目描述清楚，开发环境，项目功能，运用到哪些技术，负责哪个模块，曾经遇到哪些问题等。","categories":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"简历","slug":"简历","permalink":"mumudadi.top/tags/%E7%AE%80%E5%8E%86/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"mumudadi.top/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"职场成功的核武器","slug":"succeed","date":"2019-01-02T07:16:01.000Z","updated":"2020-02-04T14:38:50.103Z","comments":true,"path":"2019/01/02/succeed/","link":"","permalink":"mumudadi.top/2019/01/02/succeed/","excerpt":"","text":"职场成功的两条腿 硬实力：技术能力 职场的基础 小白重视 难以短时间提高 硬实力更多的是影响工作 软实力：沟通、管理能力 职场晋升的关键 观念认为是天生不可变，大多数忽视训练 短时间可以迅速提高 软实力，影响工作和人生的方方面面 人的软实力有7种能力组成： 基础实力（形象气质、声音魅力） 决定：你的人生基础（婚姻、朋友圈） 人际沟通（沟通力、说服力） 决定：能否晋升到职场中层 领导能力（影响力、领导力、情商） 决定：能否晋升到职场高层 适用范围：有某项特长能力的人不适用此7A+理论 这7种实力是完全可以通过专业训练，迅速提升的！人的能力不是天生的。形象气质力测试 形象气质是人的第一名片。对婚姻、事业有重大影响 早晨起床后，花多长时间打理形象？ A.三十分钟 B.十分钟 C.十分钟一下 多久进一次理发店？ A.一周 B.两周 C.一个月 形象礼仪在社交中的重要性 A.非常重要十分精通 B.很重要但是不懂 C.不重要也不懂 声音魅力测试 好的声音、有磁性的声音，是人的第二名片。 微信发语音时如何评价自己的声音？ A.有磁性有感染力 B.凑合能听 C.不好听 有没有人夸赞过你的声音？ A.经常有 B.偶尔 C.没有 唱歌或者大声讲话时用哪种方式呼吸？ A.熟练运用胸腹式联合呼吸法 B.了解专业发声方法但是不会用 C.完全用嗓子 沟通力测试 好的沟通，让你有好的人际关系；不沟通，没朋友，没伙伴。错误沟通，让你丢失伙伴，丢失爱人。 沟通中，能否正确觉知他人的情绪？ A.敏锐的感觉到 B.后知后觉 C.完全不知道 表达中，给别人留下的印象是？ A.条理清晰，逻辑严谨 B.意识流，想哪儿说哪儿 C.废话连篇，不知所云 如果你不赞同岳母的意见，如何反馈？ A.引导对方察觉自己的问题 B.部分认同，阐述自己的观点 C.直接反对 说服力测试 人的一生每一天都在：说服别人、被别人说服。 你要建立个团队，你能说服多少人？ A.10人 B.5人以下 C.没人 加入新团队，多长时间得到大家认同？ A.天 B.周 C.月 新认识一位女神（男神），多久可以约她（他）吃饭或者看电影？ A.周 B.月 C.年 影响力测试 能对多少人说话，就能有多大成就。 多少人认识你？ A.万 B.千 C.百 曾经在多少人面前表达自己的想法？ A.百人以上 B.十位数 C.个位数 表达自己想法时，气氛互动控场能力？ A.非常好 B.一般 C.较差 领导力测试 能领导多少人，力量就有多大。 你管理过的最大团队多少人？ A.50人以上 B.10-50 C.10以下 团队的执行程度？ A.百分之百执行 B.不完全执行 C.不执行 作为领导，下属多长时间可以领会你的意图？ A.小时 B.天 C.周 情商测试 情商不是见人说人话，见鬼说鬼话。情商是面对压力和逆境时，情绪控制能力。 坚持某个业余爱好的最长时间？ A.年 B.月 C.天 假设项目一周后上线，需要这一周通宵加班，你如何处理？ A.主动加班不惜一切代价一定完成 B.服从领导安排愿意加班 C.正常上下班，能做多少是多少 面临重大挫折，如何处理？ A.乐观积极勇敢面对 B.情绪反复 得过且过 C.消极面对 逃避问题 软实力决定人生高度 软实力可以训练，快速提高 软实力短板，决定你的发展 追求综合，不追求某一项特牛","categories":[{"name":"职场","slug":"职场","permalink":"mumudadi.top/categories/%E8%81%8C%E5%9C%BA/"}],"tags":[{"name":"职场","slug":"职场","permalink":"mumudadi.top/tags/%E8%81%8C%E5%9C%BA/"}],"keywords":[{"name":"职场","slug":"职场","permalink":"mumudadi.top/categories/%E8%81%8C%E5%9C%BA/"}]},{"title":"接到面试邀请后需要准备","slug":"interview","date":"2019-01-02T07:16:01.000Z","updated":"2020-02-04T14:38:31.946Z","comments":true,"path":"2019/01/02/interview/","link":"","permalink":"mumudadi.top/2019/01/02/interview/","excerpt":"","text":"了解公司 公司所在的行业是否有前景？ 公司历史和结构 可以通过天眼查，企查查等。避免进入传销公司，培训公司！ 公司产品和项目有哪些？ 可以通过公司官网查看，公司需要招聘志同道合的人，多了解一些和面试官也有更多的共同话题。 再回过头认真看公司的招聘信息，侧重点要哪些技术经验优先（重点复习），基本要求。确保每一条心里有数。 研究该公司产品，并提出问题 用户群体 PC端功能研究 APP端功能研究 对比同类产品有哪些？ 最后一点，用心去做！","categories":[{"name":"面试","slug":"面试","permalink":"mumudadi.top/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"mumudadi.top/tags/%E9%9D%A2%E8%AF%95/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"mumudadi.top/categories/%E9%9D%A2%E8%AF%95/"}]},{"title":"技术面试不该问的4大问题","slug":"notInquire","date":"2019-01-02T07:16:01.000Z","updated":"2020-02-04T14:38:57.185Z","comments":true,"path":"2019/01/02/notInquire/","link":"","permalink":"mumudadi.top/2019/01/02/notInquire/","excerpt":"","text":"技术面试就问技术相关的问题切勿偏题去问一些不相关的问题，例如： 我能拿多少工资？ 五险一金有没有？交通补助有没有？ 公司经常加班吗？ 您觉得我们今天能面上吗？ 有些问题可以下来问人事 面试即将结束，面试官问：您还有问题吗？这时候一定要去提问，例如：公司某个项目运用了Hadoop我不太熟悉，您能说说吗","categories":[{"name":"面试","slug":"面试","permalink":"mumudadi.top/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"mumudadi.top/tags/%E9%9D%A2%E8%AF%95/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"mumudadi.top/categories/%E9%9D%A2%E8%AF%95/"}]}]}